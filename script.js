document.addEventListener('DOMContentLoaded', () => {
    const tg = window.Telegram.WebApp;
    tg.ready(); // Signal that the app is ready
    tg.expand(); // Expand the app to full height

    // --- Configuration ---
    const CONFIG = {
        TICK_INTERVAL: 1000, // Game loop interval in milliseconds (1 second)
        SAVE_INTERVAL: 20000, // Autosave interval (20 seconds)
        CRYPTO_UPDATE_INTERVAL: 60000, // Interval for crypto price simulation (1 minute)
        EVENT_CHECK_INTERVAL: 30000, // Interval to check for random events (30 seconds)
        BASE_HASHRATE_VALUE_FACTOR: 0.001, // Base USDz value generated by 1 H/s per second (before crypto price)
        ELECTRICITY_COST_PER_WATT_SECOND: 0.0000002, // Cost in USDz per Watt per second
        REPAIR_COST_FACTOR: 1.5, // Multiplier for repair cost (BasePrice * Wear^1.5 * Factor)
        EXCHANGE_FEE_PERCENT: 1, // Crypto exchange commission percentage
        POOL_FEE_PERCENT: 2, // Default pool fee (can be overridden)
        MAX_GRAPH_POINTS: 30, // Number of data points for the crypto chart history
        WEAR_WARNING_THRESHOLD: 50, // Wear percentage to show warning color
        WEAR_DANGER_THRESHOLD: 80, // Wear percentage to show danger color and pulse
        INITIAL_BALANCE_USDZ: 100, // Starting USDz balance for new games
        INITIAL_CRYPTO_BALANCES: { BTCz: 0.001, ETHZ: 0, DOGEz: 10 }, // Starting crypto for new games
        EVENT_CHANCE_PER_INTERVAL: 0.1, // 10% chance to trigger an event each interval
        OFFLINE_EARNINGS_FACTOR: 0.5 // Multiplier for calculating potential offline earnings (to reduce abuse)
    };

    // --- UI Elements Cache ---
    const ui = {
        app: document.querySelector('.app'), // Main app container
        // Status Bar
        balanceElement: document.getElementById('player-balance'),
        walletBtcz: document.getElementById('wallet-btcz'),
        walletEthz: document.getElementById('wallet-ethz'),
        walletDogez: document.getElementById('wallet-dogez'),
        totalHashrateElement: document.getElementById('total-hashrate'),
        totalPowerElement: document.getElementById('total-power'),
        powerCostElement: document.getElementById('power-cost'),
        miningTargetElement: document.getElementById('mining-target-coin'),
        currentPoolElement: document.getElementById('current-pool-name'),
        userNameElement: document.getElementById('user-name'),
        // Event Banner
        activeEventBanner: document.getElementById('active-event-banner'),
        eventTextElement: document.getElementById('event-text'),
        // Main Screen (Farm)
        miningCoinSelect: document.getElementById('mining-coin-select'),
        motherboardSlotContainer: document.getElementById('motherboard-slot').querySelector('.slot'),
        psuSlotContainer: document.getElementById('psu-slot').querySelector('.slot'),
        rigGpuSlotsContainer: document.getElementById('rig-gpu-slots'),
        estimatedIncomeElement: document.getElementById('estimated-income'),
        estimatedIncomeCoinElement: document.getElementById('estimated-income-coin'),
        // Shop Screen
        shopItemsContainer: document.getElementById('shop-items'),
        // Crypto Market Screen
        cryptoPricesContainer: document.getElementById('crypto-prices'),
        cryptoChartCanvas: document.getElementById('crypto-chart'),
        exchangeFromCoinSelect: document.getElementById('exchange-from-coin'),
        exchangeToCoinSelect: document.getElementById('exchange-to-coin'),
        exchangeFromAmountInput: document.getElementById('exchange-from-amount'),
        fromCoinBalanceSpan: document.getElementById('from-coin-balance'),
        exchangeToAmountSpan: document.getElementById('exchange-to-amount'),
        exchangeButton: document.getElementById('exchange-button'),
        exchangeFeePercentSpan: document.getElementById('exchange-fee-percent'),
        // Used Market Screen
        marketItemsBuyContainer: document.getElementById('market-items-buy'),
        marketItemsSellContainer: document.getElementById('market-items-sell'),
        myMarketListingsContainer: document.getElementById('my-market-listings'),
        inventoryForSaleContainer: document.getElementById('inventory-for-sale'),
        // Inventory Screen
        inventoryItemsContainer: document.getElementById('inventory-items'),
        // Pools & Upgrades Screen
        poolListContainer: document.getElementById('pool-list'),
        upgradeListContainer: document.getElementById('upgrade-list'),
        // Modals
        sellModal: document.getElementById('sell-modal'),
        sellItemNameElement: document.getElementById('sell-item-name'),
        sellPriceInput: document.getElementById('sell-price-input'),
        confirmSellButton: document.getElementById('confirm-sell-button'),
        sellModalCloseButton: document.getElementById('sell-modal').querySelector('.close-button'),
        repairModal: document.getElementById('repair-modal'),
        repairItemNameElement: document.getElementById('repair-item-name'),
        repairItemWearElement: document.getElementById('repair-item-wear'),
        repairCostElement: document.getElementById('repair-cost'),
        confirmRepairButton: document.getElementById('confirm-repair-button'),
        repairModalCloseButton: document.getElementById('repair-modal').querySelector('.close-button'),
        // Templates
        componentCardTemplate: document.getElementById('component-card-template'),
        cryptoPriceTemplate: document.getElementById('crypto-price-template'),
        poolTemplate: document.getElementById('pool-template'),
        // Other Controls
        screens: document.querySelectorAll('.screen'),
        navButtons: document.querySelectorAll('.nav-button'),
        marketTabButtons: document.querySelectorAll('.market-tabs .tab-button'),
    };

    // --- Game Data Definitions ---
    const componentData = {
        // GPUs (price in USDz)
        gpu1: { id: 'gpu1', name: 'Ancient S3', price: 20, hashrate: 2, power: 20, type: 'gpu', image: genPlaceholderImg('GPU') },
        gpu2: { id: 'gpu2', name: 'Gamer 1050Ti', price: 80, hashrate: 15, power: 75, type: 'gpu', image: genPlaceholderImg('GPU') },
        gpu3: { id: 'gpu3', name: 'Solid 1660S', price: 200, hashrate: 32, power: 125, type: 'gpu', image: genPlaceholderImg('GPU') },
        gpu4: { id: 'gpu4', name: 'Pro 3070', price: 550, hashrate: 62, power: 230, type: 'gpu', image: genPlaceholderImg('GPU') },
        gpu5: { id: 'gpu5', name: 'Beast 3090', price: 1400, hashrate: 125, power: 360, type: 'gpu', image: genPlaceholderImg('GPU') },
        // PSUs
        psu1: { id: 'psu1', name: 'Office 300W', price: 30, capacity: 300, type: 'psu', image: genPlaceholderImg('PSU') },
        psu2: { id: 'psu2', name: 'Bronze 650W', price: 70, capacity: 650, type: 'psu', image: genPlaceholderImg('PSU') },
        psu3: { id: 'psu3', name: 'Gold 1000W', price: 180, capacity: 1000, type: 'psu', image: genPlaceholderImg('PSU') },
        psu4: { id: 'psu4', name: 'Titanium 1600W', price: 350, capacity: 1600, type: 'psu', image: genPlaceholderImg('PSU') },
        // Motherboards
        mobo1: { id: 'mobo1', name: 'Simple H410', price: 50, gpuSlots: 2, type: 'motherboard', power: 15, image: genPlaceholderImg('MOBO') },
        mobo2: { id: 'mobo2', name: 'Gamer B550', price: 110, gpuSlots: 4, type: 'motherboard', power: 25, image: genPlaceholderImg('MOBO') },
        mobo3: { id: 'mobo3', name: 'Mining Pro', price: 190, gpuSlots: 8, type: 'motherboard', power: 35, image: genPlaceholderImg('MOBO') },
        mobo4: { id: 'mobo4', name: 'Mining Extreme', price: 320, gpuSlots: 12, type: 'motherboard', power: 45, image: genPlaceholderImg('MOBO') },
    };

    const cryptoData = { // Base values are somewhat arbitrary, focus on relative differences
        BTCz: { id: 'BTCz', name: 'BitCoinz', icon: 'ü™ô', baseValue: 1.0, volatility: 0.1, history: [] },
        ETHZ: { id: 'ETHZ', name: 'ETHertz', icon: 'üíé', baseValue: 0.7, volatility: 0.15, history: [] },
        DOGEz: { id: 'DOGEz', name: 'DogeCoinz', icon: 'ü¶¥', baseValue: 0.1, volatility: 0.3, history: [] },
    };

    const poolData = {
        pool1: { id: 'pool1', name: 'Solo Miners', icon: 'üë§', description: '–ú–∞–π–Ω–∏–Ω–≥ –≤ –æ–¥–∏–Ω–æ—á–∫—É. –ù–µ—Ç –±–æ–Ω—É—Å–æ–≤, –Ω–µ—Ç –∫–æ–º–∏—Å—Å–∏–∏.', bonus: 0, fee: 0, minHashrate: 0 },
        pool2: { id: 'pool2', name: 'Easy Pool', icon: 'üèä', description: '–°—Ç–∞–±–∏–ª—å–Ω—ã–π –ø—É–ª –¥–ª—è –Ω–∞—á–∏–Ω–∞—é—â–∏—Ö –º–∞–π–Ω–µ—Ä–æ–≤.', bonus: 3, fee: 1, minHashrate: 50 },
        pool3: { id: 'pool3', name: 'Pro Hashers', icon: 'üöÄ', description: '–í—ã—Å–æ–∫–∏–π –±–æ–Ω—É—Å –¥–ª—è –º–æ—â–Ω—ã—Ö —Ñ–µ—Ä–º, –Ω–æ –∏ –∫–æ–º–∏—Å—Å–∏—è –≤—ã—à–µ.', bonus: 6, fee: 2, minHashrate: 500 },
        pool4: { id: 'pool4', name: 'Whale Pool', icon: 'üê≥', description: '–ú–∞–∫—Å–∏–º–∞–ª—å–Ω—ã–π –±–æ–Ω—É—Å –¥–ª—è —Ç–æ–ø–æ–≤—ã—Ö –º–∞–π–Ω–µ—Ä–æ–≤.', bonus: 8, fee: 3, minHashrate: 2000 },
    };

    const eventData = [ // Duration in seconds
        { id: 'EVENT_BTCZ_PUMP', text: 'üöÄ –ü–∞–º–ø BTCz! (+25% –∫ —Ü–µ–Ω–µ)', duration: 300, effect: { type: 'crypto_price', coin: 'BTCz', multiplier: 1.25 } },
        { id: 'EVENT_ETHZ_DUMP', text: 'üìâ –î–∞–º–ø ETHZ! (-20% –∫ —Ü–µ–Ω–µ)', duration: 240, effect: { type: 'crypto_price', coin: 'ETHZ', multiplier: 0.80 } },
        { id: 'EVENT_DOGEZ_MOON', text: 'üåï DOGEz –ª–µ—Ç–∏—Ç –Ω–∞ –õ—É–Ω—É! (+50% –∫ —Ü–µ–Ω–µ)', duration: 180, effect: { type: 'crypto_price', coin: 'DOGEz', multiplier: 1.50 } },
        { id: 'EVENT_GPU_SALE', text: 'üí∏ –†–∞—Å–ø—Ä–æ–¥–∞–∂–∞ –í–∏–¥–µ–æ–∫–∞—Ä—Ç! (-20% –≤ –º–∞–≥–∞–∑–∏–Ω–µ)', duration: 180, effect: { type: 'shop_discount', itemType: 'gpu', discount: 0.20 } },
        { id: 'EVENT_PSU_DEFICIT', text: '‚ùó –î–µ—Ñ–∏—Ü–∏—Ç –ë–ü! (+25% –∫ —Ü–µ–Ω–µ –≤ –º–∞–≥–∞–∑–∏–Ω–µ)', duration: 200, effect: { type: 'shop_price_increase', itemType: 'psu', multiplier: 1.25 } },
        { id: 'EVENT_POWER_HIKE', text: '‚ö° –≠–ª–µ–∫—Ç—Ä–∏—á–µ—Å—Ç–≤–æ –ø–æ–¥–æ—Ä–æ–∂–∞–ª–æ! (+50% –∫ —Å—Ç–æ–∏–º–æ—Å—Ç–∏)', duration: 360, effect: { type: 'electricity_cost', multiplier: 1.5 } },
        { id: 'EVENT_POWER_DROP', text: 'üí° –°–∫–∏–¥–∫–∏ –Ω–∞ —ç–ª–µ–∫—Ç—Ä–∏—á–µ—Å—Ç–≤–æ! (-30% –æ—Ç —Å—Ç–æ–∏–º–æ—Å—Ç–∏)', duration: 240, effect: { type: 'electricity_cost', multiplier: 0.7 } },
        { id: 'EVENT_MARKET_CRASH', text: 'üìâ –û–±–≤–∞–ª —Ä—ã–Ω–∫–∞ –ë/–£! (-25% –∫–æ –≤—Å–µ–º –ª–æ—Ç–∞–º)', duration: 200, effect: { type: 'used_market_price', multiplier: 0.75}},
        { id: 'EVENT_MARKET_BOOM', text: 'üìà –ê–∂–∏–æ—Ç–∞–∂ –Ω–∞ —Ä—ã–Ω–∫–µ –ë/–£! (+15% –∫ —Ü–µ–Ω–∞–º)', duration: 150, effect: { type: 'used_market_price', multiplier: 1.15}},
        { id: 'EVENT_POOL_BONUS', text: 'ü§ù –ë–æ–Ω—É—Å–Ω–∞—è –Ω–µ–¥–µ–ª—è –≤ –ø—É–ª–∞—Ö! (+2% –±–æ–Ω—É—Å –≤–æ –≤—Å–µ—Ö –ø–ª–∞—Ç–Ω—ã—Ö –ø—É–ª–∞—Ö)', duration: 400, effect: { type: 'pool_bonus_increase', amount: 2 } },
    ];

    // --- Game State Variables ---
    let gameState = {}; // Will be populated by loadGame or initializeNewGame
    let chartInstance = null; // Instance for Chart.js
    let timers = { // Store interval IDs to potentially clear them later
        gameLoop: null,
        saveGame: null,
        cryptoUpdate: null,
        eventCheck: null
    };
    let itemToSellUid = null; // UID of item being listed on market
    let itemToRepairUid = null; // UID of item being repaired

    // --- Core Logic Functions ---

    /** Initializes a new game state object. */
    function initializeNewGame() {
        gameState = {
            balance: CONFIG.INITIAL_BALANCE_USDZ, // Start with USDz
            cryptoWallet: { ...CONFIG.INITIAL_CRYPTO_BALANCES }, // Use initial crypto balances
            cryptoPrices: {}, // Current price in USDz, will be initialized
            selectedCoinId: 'BTCz', // Default mining target
            rig: {
                gpuSlots: [], // Array of GPU instances or null
                motherboard: null, // Mobo instance or null
                psu: null, // PSU instance or null
            },
            inventory: [], // Array of component instances { uid, id, wear, ... }
            marketListings: [], // Items listed by the player { uid, id, wear, price, ... }
            lastUpdate: Date.now(), // Timestamp for offline calculation
            currentPoolId: 'pool1', // Start in Solo pool
            activeEvent: null, // Currently active global event { id, text, startTime, duration, effect }
            upgrades: {}, // Player upgrades { upgradeId: level }
            stats: { // Game statistics
                 totalMined: {}, // totalMined[coinId] = amount
                 electricityPaid: 0,
                 itemsBought: 0,
                 itemsSold: 0,
                 repairsMade: 0,
                 usdEarnedFromSales: 0,
            },
        };
         // Initialize crypto prices and stats
        for (const id in cryptoData) {
            gameState.cryptoPrices[id] = cryptoData[id].baseValue;
             cryptoData[id].history = Array(CONFIG.MAX_GRAPH_POINTS).fill(cryptoData[id].baseValue); // Init history
             gameState.stats.totalMined[id] = 0;
        }
        console.log("Initialized new game state.");
    }

    /** Saves the current game state to localStorage. */
    function saveGame() {
        try {
            // Optional: Prune large data before saving if needed (e.g., history)
            // const stateToSave = { ...gameState };
            // delete stateToSave.cryptoHistory;
            localStorage.setItem('cryptoBaronGameState_v3', JSON.stringify(gameState));
            console.log("Game Saved");
        } catch (error) {
            console.error("Error saving game:", error);
            // Optionally notify user via Telegram UI if saving fails repeatedly
            // tg.showAlert("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –ø—Ä–æ–≥—Ä–µ—Å—Å–∞!");
            tg.HapticFeedback.notificationOccurred('error');
        }
    }

    /** Loads game state from localStorage or initializes a new game. */
    function loadGame() {
        const savedState = localStorage.getItem('cryptoBaronGameState_v3');
        if (savedState) {
            try {
                gameState = JSON.parse(savedState);
                console.log("Loaded game state from localStorage.");

                // --- Data Migration & Validation ---
                // Ensure essential structures exist after loading older save
                gameState.cryptoWallet = gameState.cryptoWallet || {};
                gameState.cryptoPrices = gameState.cryptoPrices || {};
                gameState.stats = gameState.stats || { totalMined: {}, electricityPaid: 0 };
                gameState.stats.totalMined = gameState.stats.totalMined || {};
                gameState.rig = gameState.rig || { gpuSlots: [], motherboard: null, psu: null };
                gameState.inventory = gameState.inventory || [];
                gameState.marketListings = gameState.marketListings || [];
                gameState.upgrades = gameState.upgrades || {};
                gameState.currentPoolId = gameState.currentPoolId || 'pool1';
                gameState.selectedCoinId = gameState.selectedCoinId || 'BTCz';
                gameState.activeEvent = gameState.activeEvent || null;

                // Initialize missing crypto data / stats
                for (const id in cryptoData) {
                    if (gameState.cryptoWallet[id] === undefined) gameState.cryptoWallet[id] = 0;
                    if (gameState.cryptoPrices[id] === undefined) gameState.cryptoPrices[id] = cryptoData[id].baseValue;
                    if (gameState.stats.totalMined[id] === undefined) gameState.stats.totalMined[id] = 0;
                    // Restore chart history (important if not saved)
                    cryptoData[id].history = Array(CONFIG.MAX_GRAPH_POINTS).fill(gameState.cryptoPrices[id]);
                }

                // Ensure rig.gpuSlots is an array
                if (!Array.isArray(gameState.rig.gpuSlots)) {
                     gameState.rig.gpuSlots = [];
                }
                 // Ensure all items have UIDs (migration from older versions if needed)
                 const fixUid = (item) => { if (item && !item.uid) item.uid = generateUid(); };
                 gameState.inventory.forEach(fixUid);
                 gameState.marketListings.forEach(fixUid);
                 gameState.rig.gpuSlots.forEach(fixUid);
                 fixUid(gameState.rig.motherboard);
                 fixUid(gameState.rig.psu);


                // --- Offline Progress (Simplified) ---
                const timeOffline = (Date.now() - (gameState.lastUpdate || Date.now())) / 1000; // seconds
                if (timeOffline > 60) { // Only calculate if offline for more than a minute
                    const offlineStats = calculateRigStats(); // Stats at the moment of closing
                    const potentialOfflineEarningsUSDZ = offlineStats.effectiveHashrate * CONFIG.BASE_HASHRATE_VALUE_FACTOR * timeOffline * CONFIG.OFFLINE_EARNINGS_FACTOR;
                    const potentialOfflineCost = offlineStats.electricityCostPerSecond * timeOffline;
                    // Simple offline simulation: Grant a portion of potential USDz earnings minus electricity cost
                     const netOfflineGain = Math.max(0, potentialOfflineEarningsUSDZ - potentialOfflineCost);
                     if (netOfflineGain > 0) {
                         gameState.balance += netOfflineGain;
                          console.log(`Applied offline earnings: +${netOfflineGain.toFixed(2)} USDz (Offline: ${Math.round(timeOffline/60)} min)`);
                          // Maybe show a notification to the user
                          tg.showAlert(`–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å!\n–ó–∞ –≤—Ä–µ–º—è –≤–∞—à–µ–≥–æ –æ—Ç—Å—É—Ç—Å—Ç–≤–∏—è (${Math.round(timeOffline/60)} –º–∏–Ω) —Ñ–µ—Ä–º–∞ –∑–∞—Ä–∞–±–æ—Ç–∞–ª–∞ ‚âà ${netOfflineGain.toFixed(2)} USDz (–∑–∞ –≤—ã—á–µ—Ç–æ–º —ç–Ω–µ—Ä–≥–∏–∏).`);
                     } else {
                         console.log(`No significant offline earnings calculated (Offline: ${Math.round(timeOffline/60)} min)`);
                     }
                }


                // Check if the active event expired while offline
                checkActiveEventExpiry();

            } catch (error) {
                 console.error("Error parsing saved state:", error, ". Starting new game.");
                 tg.showAlert("–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ. –ù–∞—á–∏–Ω–∞–µ–º –Ω–æ–≤—É—é –∏–≥—Ä—É.");
                 initializeNewGame(); // Start fresh if loading fails
            }
        } else {
            console.log("No saved state found. Initializing new game.");
            initializeNewGame();
        }
        gameState.lastUpdate = Date.now(); // Set last update time after loading/initializing
    }

    /** Generates a unique identifier string. */
    function generateUid() {
         // Combines timestamp and random chars for better uniqueness
        return Date.now().toString(36) + Math.random().toString(36).substring(2, 9);
    }

    /**
     * Finds an item instance by its UID across inventory, rig, and market listings.
     * @param {string} uid - The Unique ID of the item.
     * @returns {object|null} An object { item: object, location: string } or null if not found.
     */
    function findItemByUid(uid) {
        let item = gameState.inventory.find(i => i?.uid === uid);
        if (item) return { item, location: 'inventory' };

        if (gameState.rig.motherboard?.uid === uid) return { item: gameState.rig.motherboard, location: 'rig' };
        if (gameState.rig.psu?.uid === uid) return { item: gameState.rig.psu, location: 'rig' };

        item = gameState.rig.gpuSlots.find(i => i?.uid === uid);
        if (item) return { item, location: 'rig' };

        item = gameState.marketListings.find(i => i?.uid === uid);
        if (item) return { item, location: 'marketListings' };

        return null; // Not found anywhere
    }

    /**
     * Calculates the current statistics of the mining rig.
     * @returns {object} An object containing calculated stats like hashrate, power, costs.
     */
    function calculateRigStats() {
        let baseHashrate = 0;
        let totalPower = 0;
        let gpuCount = 0;
        const moboInstance = gameState.rig.motherboard;
        const psuInstance = gameState.rig.psu;
        const moboData = moboInstance ? componentData[moboInstance.id] : null;
        const psuData = psuInstance ? componentData[psuInstance.id] : null;

        // Base power consumption of components
        if (moboData) totalPower += moboData.power || 0;
        // Add PSU inefficiency later? For now, PSU itself doesn't add to the *load*.

        // Calculate GPU contributions
        gameState.rig.gpuSlots.forEach(gpuInstance => {
            if (gpuInstance) {
                gpuCount++;
                const gpuInfo = componentData[gpuInstance.id];
                if (gpuInfo) {
                     const wearFactor = 1.0 - (gpuInstance.wear || 0); // 1.0 = no wear, 0.0 = fully worn
                     baseHashrate += gpuInfo.hashrate * wearFactor;
                     totalPower += gpuInfo.power;
                } else {
                    console.warn(`Data not found for installed GPU ID: ${gpuInstance.id}`);
                }
            }
        });

        const psuCapacity = psuData?.capacity || 0;
        const moboSlots = moboData?.gpuSlots || 0;

        // Apply Power Supply Limit Penalty
        let powerPenalty = 1.0;
        if (psuCapacity > 0 && totalPower > psuCapacity) {
            // Penalty increases sharply as overload grows
            powerPenalty = Math.max(0, 1 - ((totalPower - psuCapacity) / psuCapacity) * 1.5);
            console.warn(`PSU Overload! ${totalPower}W / ${psuCapacity}W. Hashrate penalty: ${(1 - powerPenalty) * 100}%`);
        } else if (!psuInstance && totalPower > 0) {
             powerPenalty = 0; // No PSU, no power!
             console.warn("No PSU installed, but components require power! Hashrate set to 0.");
        }


        let effectiveHashrate = baseHashrate * powerPenalty;

        // Apply Pool Bonus (Fee is applied to earnings, not hashrate)
        let poolBonusPercent = 0;
        const pool = poolData[gameState.currentPoolId];
        if (pool && pool.bonus > 0) {
            poolBonusPercent = pool.bonus;
            // Check for pool bonus event
            if (gameState.activeEvent?.effect.type === 'pool_bonus_increase' && pool.fee > 0) { // Only bonus pools affected
                 poolBonusPercent += gameState.activeEvent.effect.amount;
                 console.log(`Event applied: Pool bonus increased by ${gameState.activeEvent.effect.amount}%`);
            }
            effectiveHashrate *= (1 + poolBonusPercent / 100);
        }

        // Apply Global Hashrate Upgrades (Example)
        // effectiveHashrate *= (1 + (gameState.upgrades.globalHashrateBoost || 0) / 100);

        // Calculate Electricity Cost
        let currentElectricityCostFactor = CONFIG.ELECTRICITY_COST_PER_WATT_SECOND;
        if (gameState.activeEvent?.effect.type === 'electricity_cost') {
             currentElectricityCostFactor *= gameState.activeEvent.effect.multiplier;
        }
        const electricityCostPerSecond = totalPower * currentElectricityCostFactor;
        const electricityCostPerHour = electricityCostPerSecond * 3600; // Cost in USDz

        // Calculate Estimated Net Income Per Hour (in selected coin)
        const targetCoinId = gameState.selectedCoinId;
        const targetCoinPrice = gameState.cryptoPrices[targetCoinId] || 0;
        // Calculate gross earnings in USDz value first
        const grossUsdValuePerSecond = effectiveHashrate * CONFIG.BASE_HASHRATE_VALUE_FACTOR;
        // Net USDz value per second after electricity
        const netUsdValuePerSecond = grossUsdValuePerSecond - electricityCostPerSecond;
        // Convert net USDz value to target coin amount
        const estimatedNetIncomePerSecondCoin = targetCoinPrice > 0 ? netUsdValuePerSecond / targetCoinPrice : 0;
        const estimatedNetIncomePerHourCoin = estimatedNetIncomePerSecondCoin * 3600;


        return {
            totalHashrate: baseHashrate, // Raw hashrate before penalties/bonuses
            effectiveHashrate: effectiveHashrate, // Hashrate used for earning calculation
            totalPower: totalPower, // Total power consumption
            psuCapacity: psuCapacity, // Max power supported by PSU
            moboSlots: moboSlots, // Max GPU slots on Mobo
            gpuCount: gpuCount, // Number of installed GPUs
            electricityCostPerSecond: electricityCostPerSecond, // Cost in USDz/sec
            electricityCostPerHour: electricityCostPerHour, // Cost in USDz/hour
            estimatedNetIncomePerHourCoin: estimatedNetIncomePerHourCoin, // Estimated net gain in selected coin/hour
            poolBonusPercent: poolBonusPercent // Active pool bonus %
        };
    }

    /** Simulates fluctuations in cryptocurrency prices. */
    function simulateCryptoMarket() {
        let pricesChanged = false;
        for (const id in cryptoData) {
            const coin = cryptoData[id];
            const currentPrice = gameState.cryptoPrices[id] || coin.baseValue; // Fallback to base if undefined
            const volatility = coin.volatility;

            // Simple random walk with mean reversion tendency
            const randomFactor = (Math.random() - 0.5) * 2; // -1 to +1
            const changePercent = randomFactor * volatility;
            let newPrice = currentPrice * (1 + changePercent);

            // Mean reversion pull towards base value (stronger if further away)
            const diffToBase = coin.baseValue - newPrice;
            newPrice += diffToBase * 0.02; // Gently pull 2% towards base each tick

            // Prevent extreme values
            newPrice = Math.max(coin.baseValue * 0.1, newPrice); // Floor at 10% of base
            newPrice = Math.min(coin.baseValue * 10, newPrice); // Cap at 10x base

            // Apply crypto price event modifier (overrides other logic if active)
            if (gameState.activeEvent?.effect.type === 'crypto_price' && gameState.activeEvent.effect.coin === id) {
                newPrice = currentPrice * gameState.activeEvent.effect.multiplier; // Apply event multiplier directly for duration
                console.log(`Event affecting ${id}: price forced by multiplier ${gameState.activeEvent.effect.multiplier}`);
            }


            // Update state only if price changed significantly
            if (Math.abs(newPrice - currentPrice) > 0.00001) {
                pricesChanged = true;
                gameState.cryptoPrices[id] = newPrice;

                // Update history for chart
                coin.history.push(newPrice);
                if (coin.history.length > CONFIG.MAX_GRAPH_POINTS) {
                    coin.history.shift(); // Remove the oldest data point
                }
            }
        }
        if (pricesChanged) {
            console.log("Crypto prices updated:", gameState.cryptoPrices);
            // Update relevant UI parts if the market screen is active or prices are shown elsewhere
             if (document.getElementById('screen-crypto-market')?.classList.contains('active')) {
                 renderCryptoMarket(); // Re-render the whole market
             } else {
                 updateCryptoPricesUI(); // Only update price displays if market not active
             }
             // Exchange estimates might need update if exchange form is visible
             if (document.getElementById('screen-crypto-market')?.classList.contains('active')) {
                updateExchangeEstimate();
             }
        }
    }

    /** Checks for and potentially triggers a random global event. */
    function triggerRandomEvent() {
          if (gameState.activeEvent) return; // Don't trigger if one is already active

          if (Math.random() < CONFIG.EVENT_CHANCE_PER_INTERVAL) {
               const availableEvents = eventData; // Could filter based on game progress later
               if (availableEvents.length === 0) return;

               const randomIndex = Math.floor(Math.random() * availableEvents.length);
               const event = { ...availableEvents[randomIndex] }; // Clone event data

               gameState.activeEvent = {
                    id: event.id,
                    text: event.text,
                    startTime: Date.now(),
                    duration: event.duration * 1000, // Convert duration to milliseconds
                    effect: { ...event.effect }, // Clone effect data
               };
               console.log(`%cEVENT TRIGGERED: ${event.text}`, 'color: blue; font-weight: bold;');
               tg.HapticFeedback.notificationOccurred('warning');
               renderActiveEventUI(); // Show banner immediately

               // Immediately re-render UI elements affected by static changes
               // (like shop prices, market prices, pool list bonuses)
                if (['shop_discount', 'shop_price_increase', 'used_market_price', 'pool_bonus_increase', 'electricity_cost', 'crypto_price'].includes(event.effect.type)) {
                     updateAllUI();
                }
          }
     }

    /** Checks if the currently active event has expired and removes it if so. */
    function checkActiveEventExpiry() {
          if (!gameState.activeEvent) return;

          const now = Date.now();
          const endTime = gameState.activeEvent.startTime + gameState.activeEvent.duration;

          if (now >= endTime) {
               const expiredEventText = gameState.activeEvent.text;
               const expiredEventType = gameState.activeEvent.effect.type;
               console.log(`%cEVENT EXPIRED: ${expiredEventText}`, 'color: gray;');
               gameState.activeEvent = null;
               tg.HapticFeedback.impactOccurred('light');
               renderActiveEventUI(); // Hide banner

               // Re-render UI if the event affected static data to revert the effect display
               if (['shop_discount', 'shop_price_increase', 'used_market_price', 'pool_bonus_increase', 'electricity_cost', 'crypto_price'].includes(expiredEventType)) {
                    updateAllUI();
               }
          }
    }

    /** The main game loop, runs at TICK_INTERVAL. */
    function gameLoop() {
        const now = Date.now();
        const deltaTime = Math.max(0, Math.min(5, (now - gameState.lastUpdate) / 1000)); // Clamp deltaTime
        if (deltaTime <= 0) {
            gameState.lastUpdate = now;
            return; // Skip tick if no time passed or clock issue
        }

        const stats = calculateRigStats();
        const targetCoinId = gameState.selectedCoinId;

        // 1. Mining Earnings Calculation
        // Base earnings in USDz value per second
        const grossUsdValuePerSecond = stats.effectiveHashrate * CONFIG.BASE_HASHRATE_VALUE_FACTOR;

        // Apply Pool Fee (calculated based on gross USDz value)
        const pool = poolData[gameState.currentPoolId];
        let poolFeeUsdValue = 0;
        if (pool && pool.fee > 0) {
            poolFeeUsdValue = grossUsdValuePerSecond * (pool.fee / 100);
            // Deduct fee from player's main USDz balance? Or just reduce earnings?
            // Let's deduct from USDz balance if possible.
        }

        // Net USDz value after potential pool fee
        const netUsdValueAfterFeePerSecond = grossUsdValuePerSecond - poolFeeUsdValue;

        // 2. Electricity Cost Calculation
        const electricityCostThisTick = stats.electricityCostPerSecond * deltaTime;

        // 3. Check if player can afford electricity and pool fee
        const totalCostsPerSecond = stats.electricityCostPerSecond + poolFeeUsdValue;
        const totalCostsThisTick = totalCostsPerSecond * deltaTime;

        let canAffordCosts = gameState.balance >= totalCostsThisTick;
        let actualEarningsThisTick = 0; // In target crypto amount

        if (canAffordCosts) {
            // Deduct costs from USDz balance
            gameState.balance -= totalCostsThisTick;
            gameState.stats.electricityPaid += electricityCostThisTick;
            // Calculate earnings in target crypto if costs are covered
            const targetCoinPrice = gameState.cryptoPrices[targetCoinId] || 0;
            if (targetCoinPrice > 0) {
                actualEarningsThisTick = (netUsdValueAfterFeePerSecond * deltaTime) / targetCoinPrice;
                if (actualEarningsThisTick > 0) {
                    gameState.cryptoWallet[targetCoinId] = (gameState.cryptoWallet[targetCoinId] || 0) + actualEarningsThisTick;
                    gameState.stats.totalMined[targetCoinId] = (gameState.stats.totalMined[targetCoinId] || 0) + actualEarningsThisTick;
                }
            }
        } else {
            // Cannot afford costs fully
            console.warn(`Not enough USDz (${gameState.balance.toFixed(2)}) to cover costs (${totalCostsThisTick.toFixed(2)})! Mining ineffective.`);
            // Pay what's possible, prioritize electricity?
            const affordableElectricity = Math.min(electricityCostThisTick, gameState.balance);
            gameState.stats.electricityPaid += affordableElectricity;
            gameState.balance -= affordableElectricity;
            // No earnings if electricity isn't fully covered? Or partial earnings? Let's go with no earnings.
            actualEarningsThisTick = 0;
            // Optionally add a visual warning in UI
        }

        // 4. Component Wear Calculation
        const wearRatePerSecond = 0.000005; // Base wear rate
        const wearDelta = wearRatePerSecond * deltaTime;
        // Apply wear to installed components
        gameState.rig.gpuSlots.forEach(gpu => {
            if (gpu) gpu.wear = Math.min(1.0, (gpu.wear || 0) + wearDelta);
        });
        if (gameState.rig.psu) gameState.rig.psu.wear = Math.min(1.0, (gameState.rig.psu.wear || 0) + wearDelta * 0.5); // PSU wears slower
        if (gameState.rig.motherboard) gameState.rig.motherboard.wear = Math.min(1.0, (gameState.rig.motherboard.wear || 0) + wearDelta * 0.2); // Mobo wears slowest

        // --- Update state ---
        gameState.lastUpdate = now;

        // --- Update frequently changing UI elements ---
        // (Balances, hashrate, power, cost, pool name, etc.)
        updateStatusBarUI(stats); // Update status bar elements

    } // End gameLoop

    // --- Helper Functions ---

    /** Formats crypto amounts for display. */
    function formatCrypto(amount) {
        if (amount === undefined || amount === null || isNaN(amount)) return '0';
        if (amount === 0) return '0';
        if (amount < 0.0001 && amount > 0) return amount.toExponential(2); // Use scientific for very small numbers
        if (amount < 1) return amount.toFixed(6); // More precision for small fractional amounts
        if (amount < 1000) return amount.toFixed(4);
        if (amount < 100000) return amount.toFixed(2);
        return Math.floor(amount).toLocaleString(); // Use locale string for large whole numbers
    }

    /** Formats USDz amounts for display. */
    function formatUsd(amount) {
         if (amount === undefined || amount === null || isNaN(amount)) return '0';
         return Math.floor(amount).toLocaleString(); // Display whole numbers for USDz
    }

    /** Generates a placeholder SVG image data URL. */
    function genPlaceholderImg(text = 'IMG', width = 100, height = 100) {
        const bgColor = '#cccccc';
        const textColor = '#555555';
        // Simple SVG with text
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" width="${width}" height="${height}" viewBox="0 0 ${width} ${height}">
                        <rect width="100%" height="100%" fill="${bgColor}"/>
                        <text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-family="sans-serif" font-size="14" fill="${textColor}" font-weight="bold">${text}</text>
                     </svg>`;
        // Encode SVG to Base64
        return `data:image/svg+xml;base64,${btoa(svg)}`;
    }

     /** Creates a standard button element. */
     function createButton(text, className, onClick, disabled = false) {
         const button = document.createElement('button');
         button.type = 'button'; // Explicitly set type
         button.className = className;
         button.textContent = text;
         if (onClick) button.addEventListener('click', onClick);
         button.disabled = disabled;
         return button;
     }

    /** Calculates the cost to repair an item based on its wear and base price. */
    function calculateRepairCost(itemInstance) {
         if (!itemInstance || !itemInstance.wear || itemInstance.wear <= 0) return 0;
         const basePrice = componentData[itemInstance.id]?.price || 0;
         if (basePrice <= 0) return 1; // Minimum cost even for free items?
         // Cost increases exponentially with wear
         const cost = Math.floor(basePrice * Math.pow(itemInstance.wear, 1.5) * CONFIG.REPAIR_COST_FACTOR);
         return Math.max(1, cost); // Minimum repair cost is 1 USDz
     }


    // --- UI Rendering Functions ---

    /** Applies theme parameters from Telegram to CSS variables. */
    function applyTheme() {
        const root = document.documentElement;
        const params = tg.themeParams;
        // Map theme keys to CSS variables
        const themeMap = {
            bg_color: '--tg-theme-bg-color',
            text_color: '--tg-theme-text-color',
            hint_color: '--tg-theme-hint-color',
            link_color: '--tg-theme-link-color',
            button_color: '--tg-theme-button-color',
            button_text_color: '--tg-theme-button-text-color',
            secondary_bg_color: '--tg-theme-secondary-bg-color'
        };
        // Set default fallbacks
        root.style.setProperty('--tg-theme-bg-color', params.bg_color || '#ffffff');
        root.style.setProperty('--tg-theme-text-color', params.text_color || '#000000');
        root.style.setProperty('--tg-theme-hint-color', params.hint_color || '#999999');
        root.style.setProperty('--tg-theme-link-color', params.link_color || '#2481cc');
        root.style.setProperty('--tg-theme-button-color', params.button_color || '#2481cc');
        root.style.setProperty('--tg-theme-button-text-color', params.button_text_color || '#ffffff');
        root.style.setProperty('--tg-theme-secondary-bg-color', params.secondary_bg_color || '#f1f1f1');

        // Apply derived variables (accent color, etc.) based on the theme
        root.style.setProperty('--accent-color', params.button_color || '#2481cc');
        // Basic darken function (replace with a more robust one if needed)
         const darken = (color, percent) => {
             try {
                 if (!color || typeof color !== 'string' || color.charAt(0) !== '#') return color; // Basic validation
                 let num = parseInt(color.slice(1), 16);
                 let amt = Math.round(2.55 * percent);
                 let R = Math.max(0, (num >> 16) - amt);
                 let G = Math.max(0, (num >> 8 & 0x00FF) - amt);
                 let B = Math.max(0, (num & 0x0000FF) - amt);
                 return "#" + (0x1000000 + R*0x10000 + G*0x100 + B).toString(16).slice(1);
             } catch(e) { return color; } // fallback
         };
        root.style.setProperty('--accent-color-dark', darken(params.button_color || '#2481cc', 15));

        // Re-render chart with new theme colors if it exists
        if (chartInstance) {
            chartInstance.options.scales.y.ticks.color = params.text_color || '#000';
            chartInstance.data.datasets[0].borderColor = params.link_color || 'rgb(75, 192, 192)';
             chartInstance.data.datasets[0].backgroundColor = (params.link_color || 'rgb(75, 192, 192)') + '33'; // Add alpha
            chartInstance.update('none'); // Update without animation
        }
         console.log("Theme applied.");
    }

    /**
     * Renders a component card based on its data, instance, and location.
     * @param {object} itemData - Base data from `componentData`.
     * @param {object|null} itemInstance - The actual item instance from `gameState` (includes uid, wear).
     * @param {string} location - Context where the card is displayed ('shop', 'inventory', 'rig', etc.).
     * @returns {HTMLElement} The rendered card element.
     */
    function renderComponentCard(itemData, itemInstance = null, location = 'shop') {
        if (!itemData) {
            console.error("renderComponentCard: itemData is missing!");
            return document.createElement('div'); // Return empty div on error
        }

        const templateNode = ui.componentCardTemplate.content.cloneNode(true);
        const card = templateNode.querySelector('.item-card');
        const statsContainer = card.querySelector('.item-stats');
        const actionsContainer = card.querySelector('.item-actions');
        const wearElement = card.querySelector('.item-wear');
        const wearValueSpan = wearElement.querySelector('.wear-value');
        const priceElement = card.querySelector('.item-price');
        const priceValueSpan = priceElement.querySelector('.price-value');

        const displayItem = itemInstance || itemData;
        const uid = itemInstance?.uid;
        const wear = itemInstance?.wear || 0;
        const basePrice = itemData.price;

        card.querySelector('.item-image').src = displayItem.image || genPlaceholderImg(itemData.type.toUpperCase());
        card.querySelector('.item-image').alt = itemData.name;
        card.querySelector('.item-name').textContent = itemData.name;

        // --- Render Stats ---
        statsContainer.innerHTML = ''; // Clear previous stats
        if (itemData.type === 'gpu') {
            const currentHashrate = (itemData.hashrate * (1 - wear));
            statsContainer.innerHTML = `
                <p><span class="icon">‚ö°Ô∏è</span> H/s: ${currentHashrate.toFixed(1)} ${wear > 0 ? '('+itemData.hashrate+')' : ''}</p>
                <p><span class="icon">üîå</span> Power: ${itemData.power} W</p>
            `;
        } else if (itemData.type === 'psu') {
            statsContainer.innerHTML = `<p><span class="icon">üí°</span> Capacity: ${itemData.capacity} W</p>`;
        } else if (itemData.type === 'motherboard') {
            statsContainer.innerHTML = `
                <p><span class="icon">üñ•Ô∏è</span> GPU Slots: ${itemData.gpuSlots}</p>
                <p><span class="icon">üîå</span> Power: ${itemData.power} W</p>`;
        }

        // --- Render Wear ---
        if (itemInstance && itemData.type !== 'psu' && itemData.type !== 'motherboard') { // Only show wear for GPUs for now? Or all? Show for all instances.
             const wearPercent = (wear * 100);
             wearValueSpan.textContent = wearPercent.toFixed(1);
             wearElement.style.display = 'block';
             wearElement.classList.remove('warning', 'danger');
             if (wearPercent >= CONFIG.WEAR_DANGER_THRESHOLD) wearElement.classList.add('danger');
             else if (wearPercent >= CONFIG.WEAR_WARNING_THRESHOLD) wearElement.classList.add('warning');
        } else {
             wearElement.style.display = 'none';
        }

        // --- Render Price (USDz) ---
        let displayPrice = 0;
        let priceVisible = false;
        if (location === 'shop') {
             let currentPrice = basePrice;
             // Apply shop discount/increase event
             if (gameState.activeEvent?.effect.type === 'shop_discount' &&
                 (!gameState.activeEvent.effect.itemType || gameState.activeEvent.effect.itemType === itemData.type)) {
                  currentPrice *= (1 - gameState.activeEvent.effect.discount);
             } else if (gameState.activeEvent?.effect.type === 'shop_price_increase' &&
                 (!gameState.activeEvent.effect.itemType || gameState.activeEvent.effect.itemType === itemData.type)) {
                  currentPrice *= gameState.activeEvent.effect.multiplier;
             }
             displayPrice = Math.round(currentPrice);
             priceVisible = true;
        } else if (location === 'market-buy' || location === 'my-listing') {
             displayPrice = itemInstance?.price || 0; // Price from listing
             // Apply used market event multiplier only for 'market-buy' view
             if (location === 'market-buy' && gameState.activeEvent?.effect.type === 'used_market_price') {
                  displayPrice = Math.round(displayPrice * gameState.activeEvent.effect.multiplier);
             }
             priceVisible = true;
        }

         if (priceVisible) {
             priceElement.style.display = 'block';
             priceValueSpan.textContent = formatUsd(displayPrice);
         } else {
              priceElement.style.display = 'none';
         }

        // --- Render Actions ---
        actionsContainer.innerHTML = ''; // Clear previous actions
        const playerBalance = gameState.balance; // Cache balance for checks

        if (location === 'shop') {
            actionsContainer.appendChild(
                 createButton('–ö—É–ø–∏—Ç—å', 'buy-button action-button', () => buyItem(itemData.id), playerBalance < displayPrice)
            );
        } else if (location === 'inventory' && itemInstance) {
            actionsContainer.appendChild(
                 createButton('–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å', 'install-button action-button', () => installItemFromInventory(uid))
            );
            if (itemInstance.wear > 0.01) { // Show repair button only if worn
                 const repairCost = calculateRepairCost(itemInstance);
                 actionsContainer.appendChild(
                     createButton(`–†–µ–º–æ–Ω—Ç (${formatUsd(repairCost)}üí∞)`, 'repair-button action-button', () => openRepairModal(uid), playerBalance < repairCost)
                 );
            }
            actionsContainer.appendChild(
                 createButton('–ü—Ä–æ–¥–∞—Ç—å –Ω–∞ –ë/–£', 'list-market-button action-button', () => openSellModal(uid))
            );
        } else if (location === 'rig' && itemInstance) {
             if (itemInstance.wear > 0.01) {
                 const repairCost = calculateRepairCost(itemInstance);
                 actionsContainer.appendChild(
                     createButton(`–†–µ–º–æ–Ω—Ç (${formatUsd(repairCost)}üí∞)`, 'repair-button action-button', () => openRepairModal(uid), playerBalance < repairCost)
                 );
             }
            actionsContainer.appendChild(
                 createButton('–£–±—Ä–∞—Ç—å', 'remove-button action-button', () => uninstallItem(uid))
            );
        } else if (location === 'market-buy' && itemInstance) {
            // Display price already includes event effect
            actionsContainer.appendChild(
                 createButton(`–ö—É–ø–∏—Ç—å –ë/–£ (${formatUsd(displayPrice)}üí∞)`, 'buy-button action-button', () => buyFromMarket(itemInstance), playerBalance < displayPrice)
            );
        } else if (location === 'inventory-for-sale' && itemInstance) { // Item shown on the 'Sell' tab of used market
            actionsContainer.appendChild(
                 createButton('–í—ã—Å—Ç–∞–≤–∏—Ç—å', 'list-market-button action-button', () => openSellModal(uid))
            );
        } else if (location === 'my-listing' && itemInstance) { // Item already listed by player
             actionsContainer.appendChild(
                 createButton('–°–Ω—è—Ç—å —Å –ø—Ä–æ–¥–∞–∂–∏', 'delist-button action-button', () => delistItem(uid))
             );
        }

        return card;
    }

    /** Renders the shop screen with available components. */
    function renderShop() {
        ui.shopItemsContainer.innerHTML = ''; // Clear previous items
        const items = Object.values(componentData);
        if (items.length === 0) {
             ui.shopItemsContainer.innerHTML = '<p class="placeholder-text">–ú–∞–≥–∞–∑–∏–Ω –≤—Ä–µ–º–µ–Ω–Ω–æ –ø—É—Å—Ç.</p>'; return;
        }
        items.forEach(item => {
            ui.shopItemsContainer.appendChild(renderComponentCard(item, null, 'shop'));
        });
    }

    /** Renders the player's inventory screen. */
    function renderInventory() {
        ui.inventoryItemsContainer.innerHTML = '';
        if (gameState.inventory.length === 0) {
             ui.inventoryItemsContainer.innerHTML = '<p class="placeholder-text">–ò–Ω–≤–µ–Ω—Ç–∞—Ä—å –ø—É—Å—Ç. –ö—É–ø–∏—Ç–µ —á—Ç–æ-–Ω–∏–±—É–¥—å!</p>'; return;
        }
        // Sort inventory? Maybe by type then name?
         const sortedInventory = [...gameState.inventory].sort((a, b) => {
              if (a.type !== b.type) return a.type.localeCompare(b.type);
              return (componentData[a.id]?.price || 0) - (componentData[b.id]?.price || 0); // Sort by price within type
         });

        sortedInventory.forEach(item => {
             if (componentData[item.id]) { // Check if base data exists
                 ui.inventoryItemsContainer.appendChild(renderComponentCard(componentData[item.id], item, 'inventory'));
             } else {
                  console.warn(`Base data missing for inventory item ID: ${item.id}, UID: ${item.uid}`);
                  // Optionally render a placeholder for missing data items
             }
        });
    }

    /** Renders the main farm screen (rig slots). */
    function renderRig() {
        const renderSlot = (container, itemInstance, type, clickHandler) => {
            container.innerHTML = '';
            container.className = 'slot'; // Reset classes
            if (itemInstance) {
                container.classList.add('filled');
                const baseData = componentData[itemInstance.id];
                if (baseData) {
                    container.appendChild(renderComponentCard(baseData, itemInstance, 'rig'));
                } else {
                     container.innerHTML = `<p class="placeholder-text error">–û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö</p>`; // Handle missing base data
                     console.error(`Missing base data for installed ${type}: ID ${itemInstance.id}`);
                }
            } else {
                container.classList.add('empty');
                container.innerHTML = `–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å ${type === 'motherboard' ? '–ú–∞—Ç. –ü–ª–∞—Ç—É' : '–ë–ü'}`;
                container.onclick = clickHandler; // Assign click only if empty
            }
        };

        // Render Motherboard and PSU Slots
        renderSlot(ui.motherboardSlotContainer, gameState.rig.motherboard, 'motherboard', () => installItemFromInventory(null, 'motherboard'));
        renderSlot(ui.psuSlotContainer, gameState.rig.psu, 'psu', () => installItemFromInventory(null, 'psu'));

        // --- Render GPU Slots ---
        ui.rigGpuSlotsContainer.innerHTML = ''; // Clear GPU slots
        const moboInstance = gameState.rig.motherboard;
        const numSlots = moboInstance ? (componentData[moboInstance.id]?.gpuSlots || 0) : 0;

        if (numSlots === 0) {
             ui.rigGpuSlotsContainer.innerHTML = moboInstance
                 ? '<p class="placeholder-text">–ù–∞ —ç—Ç–æ–π –º–∞—Ç. –ø–ª–∞—Ç–µ –Ω–µ—Ç —Å–ª–æ—Ç–æ–≤ GPU.</p>'
                 : '<p class="placeholder-text">–£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –º–∞—Ç–µ—Ä–∏–Ω—Å–∫—É—é –ø–ª–∞—Ç—É –¥–ª—è –¥–æ—Å—Ç—É–ø–∞ –∫ —Å–ª–æ—Ç–∞–º GPU</p>';
        } else {
             // Ensure rig.gpuSlots array matches mobo capacity
             if (!Array.isArray(gameState.rig.gpuSlots)) gameState.rig.gpuSlots = []; // Ensure it's an array
             if (gameState.rig.gpuSlots.length !== numSlots) {
                 const currentGpus = gameState.rig.gpuSlots.filter(Boolean); // Get actual installed GPUs
                 gameState.rig.gpuSlots = Array(numSlots).fill(null); // Create new array of correct size
                 const movedToInventory = [];
                 currentGpus.forEach((gpu, i) => {
                      if (i < numSlots) {
                           gameState.rig.gpuSlots[i] = gpu; // Place back GPUs that fit
                      } else {
                           movedToInventory.push(gpu); // Collect excess GPUs
                      }
                 });
                  if (movedToInventory.length > 0) {
                      gameState.inventory.push(...movedToInventory); // Add excess GPUs back to inventory
                       console.log(`${movedToInventory.length} GPU(s) moved to inventory due to slot change.`);
                       tg.HapticFeedback.notificationOccurred('warning');
                       tg.showAlert(`–ù–µ–∫–æ—Ç–æ—Ä—ã–µ –≤–∏–¥–µ–æ–∫–∞—Ä—Ç—ã (${movedToInventory.length}) –±—ã–ª–∏ —É–±—Ä–∞–Ω—ã –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—å –∏–∑-–∑–∞ —Å–º–µ–Ω—ã –º–∞—Ç–µ—Ä–∏–Ω—Å–∫–æ–π –ø–ª–∞—Ç—ã.`);
                       if (document.getElementById('screen-inventory')?.classList.contains('active')) {
                           renderInventory(); // Update inventory screen if active
                       }
                  }
                  console.log("Adjusted GPU slots array based on motherboard.");
                  saveGame(); // Save immediately after adjusting slots
             }

             // Render individual GPU slots
             for (let i = 0; i < numSlots; i++) {
                 const gpuInstance = gameState.rig.gpuSlots[i];
                 const slotElement = document.createElement('div');
                 slotElement.className = 'item-card gpu-slot'; // Base style from item-card
                 slotElement.dataset.index = i; // Store index for installation

                 if (gpuInstance) {
                      const gpuBaseData = componentData[gpuInstance.id];
                      if (gpuBaseData) {
                           slotElement.classList.add('filled');
                           // Render the component card content directly into the slot
                           const gpuCardContent = renderComponentCard(gpuBaseData, gpuInstance, 'rig');
                           while (gpuCardContent.firstChild) {
                               slotElement.appendChild(gpuCardContent.firstChild);
                           }
                      } else {
                           // Handle case where GPU instance exists but base data is missing
                           slotElement.classList.add('filled', 'error'); // Add error class?
                           slotElement.innerHTML = '<p class="placeholder-text">–û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö GPU</p>';
                            console.error(`Missing base data for installed GPU: ID ${gpuInstance.id}`);
                      }
                 } else {
                     slotElement.classList.add('empty');
                     slotElement.innerHTML = '<p class="placeholder-text">–ü—É—Å—Ç–æ–π —Å–ª–æ—Ç GPU</p>';
                     slotElement.onclick = () => installItemFromInventory(null, 'gpu', i); // Handler for empty slot click
                 }
                 ui.rigGpuSlotsContainer.appendChild(slotElement);
             }
        }
        // Update estimated income display after rendering rig
        updateEstimatedIncomeUI();
    }

    /** Renders the used components market screen. */
    function renderMarketUsed() {
        // --- Render "Buy" Tab (Simulated Listings) ---
        ui.marketItemsBuyContainer.innerHTML = '';
         const listings = [];
         const numListings = 12; // Number of simulated listings
         const itemTypes = ['gpu', 'psu', 'motherboard']; // Types to include

         for(let i = 0; i < numListings; i++) {
              // Select a random type
              const randomType = itemTypes[Math.floor(Math.random() * itemTypes.length)];
              const availableItems = Object.values(componentData).filter(item => item.type === randomType);
              if (availableItems.length === 0) continue;

              // Select a random item of that type
              const randomItemData = availableItems[Math.floor(Math.random() * availableItems.length)];

              // Simulate wear and price
              const wear = Math.random() * 0.6; // Simulate up to 60% wear
              let price = Math.floor(randomItemData.price * (1 - wear) * (0.6 + Math.random() * 0.3)); // 60-90% of new price, adjusted for wear
              price = Math.max(1, price); // Minimum price of 1

              // Apply market crash/boom event multiplier
              if (gameState.activeEvent?.effect.type === 'used_market_price') {
                   price = Math.round(price * gameState.activeEvent.effect.multiplier);
                   price = Math.max(1, price); // Ensure price doesn't drop below 1
              }

              // Create the listing object (simulating what a real backend might return)
              listings.push({
                   ...randomItemData, // Spread base data (careful not to overwrite id/type if needed)
                   id: randomItemData.id, // Ensure original ID is preserved
                   type: randomItemData.type, // Ensure original type is preserved
                   uid: `market-${generateUid()}`, // Unique ID FOR THE LISTING itself
                   wear: wear,
                   price: price, // The calculated selling price
                   seller: `Player${Math.floor(Math.random()*5000)}` // Fake seller name
              });
         }

         if (listings.length === 0) {
             ui.marketItemsBuyContainer.innerHTML = '<p class="placeholder-text">–ù–∞ —Ä—ã–Ω–∫–µ –ë/–£ –ø–æ–∫–∞ –ø—É—Å—Ç–æ.</p>';
         } else {
            listings.forEach(listingInstance => { // This instance is the simulated listing
                 // Pass the base data and the listing instance to the renderer
                 ui.marketItemsBuyContainer.appendChild(renderComponentCard(componentData[listingInstance.id], listingInstance, 'market-buy'));
             });
         }

        // --- Render "Sell" Tab ---
        // 1. Player's Active Listings
        ui.myMarketListingsContainer.innerHTML = '';
        if (gameState.marketListings.length === 0) {
            ui.myMarketListingsContainer.innerHTML = '<p class="placeholder-text">–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ª–æ—Ç–æ–≤.</p>';
        } else {
            gameState.marketListings.forEach(itemInstance => { // itemInstance is from player's listings
                 ui.myMarketListingsContainer.appendChild(renderComponentCard(componentData[itemInstance.id], itemInstance, 'my-listing'));
            });
        }

        // 2. Inventory Items Available for Sale
        ui.inventoryForSaleContainer.innerHTML = '';
         // Filter inventory: items not currently listed
         const inventoryToSell = gameState.inventory.filter(invItem =>
             !gameState.marketListings.some(listItem => listItem.uid === invItem.uid)
         );
         if (inventoryToSell.length === 0) {
             ui.inventoryForSaleContainer.innerHTML = '<p class="placeholder-text">–í –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ –Ω–µ—Ç –ø—Ä–µ–¥–º–µ—Ç–æ–≤ –¥–ª—è –ø—Ä–æ–¥–∞–∂–∏.</p>';
        } else {
             inventoryToSell.forEach(itemInstance => { // itemInstance is from player's inventory
                 ui.inventoryForSaleContainer.appendChild(renderComponentCard(componentData[itemInstance.id], itemInstance, 'inventory-for-sale'));
            });
        }
    }

    /** Renders the cryptocurrency market screen (prices, chart, exchange). */
    function renderCryptoMarket() {
         renderCryptoPricesUI(); // Update price displays
         renderChart(); // Update the chart
         populateExchangeSelects(); // Ensure selects are up-to-date
         updateExchangeEstimate(); // Update exchange estimate based on current prices/selection
         ui.exchangeFeePercentSpan.textContent = CONFIG.EXCHANGE_FEE_PERCENT;
     }

    /** Renders only the crypto price elements. */
    function renderCryptoPricesUI() {
        ui.cryptoPricesContainer.innerHTML = ''; // Clear previous prices
         let pricesChangedSinceLastRender = false; // Flag for animation

         for (const id in cryptoData) {
             const coin = cryptoData[id];
             const price = gameState.cryptoPrices[id];
             const history = coin.history;
             const prevPrice = history.length > 1 ? history[history.length - 2] : price; // Get previous price from history
             const change = price - prevPrice;
             const changePercent = prevPrice > 0 ? (change / prevPrice) * 100 : 0;

             const templateNode = ui.cryptoPriceTemplate.content.cloneNode(true);
             const item = templateNode.querySelector('.crypto-price-item');
             const changeSpan = item.querySelector('.crypto-change');

             item.querySelector('.crypto-icon').textContent = coin.icon;
             item.querySelector('.crypto-name').textContent = coin.name;
             item.querySelector('.crypto-value').textContent = price.toFixed(3); // Price in USDz

             changeSpan.textContent = `${change >= 0 ? '+' : ''}${changePercent.toFixed(1)}%`;
             changeSpan.className = 'crypto-change ' + (change >= 0.00001 ? 'positive' : (change <= -0.00001 ? 'negative' : 'neutral'));

             // Add animation class if price changed recently
             if (Math.abs(change) > 0.00001) {
                 item.classList.add('changed');
                 pricesChangedSinceLastRender = true;
             }

             ui.cryptoPricesContainer.appendChild(item);
         }

         // Remove the animation class after a short delay
         if (pricesChangedSinceLastRender) {
              setTimeout(() => {
                   ui.cryptoPricesContainer.querySelectorAll('.changed').forEach(el => el.classList.remove('changed'));
              }, 500); // Match CSS transition duration
         }
    }

    /** Renders/updates the crypto price chart using Chart.js. */
    function renderChart() {
          if (!window.Chart) {
               console.error("Chart.js library is not loaded.");
               ui.cryptoChartCanvas.style.display = 'none'; // Hide canvas if library missing
               return;
          }
          ui.cryptoChartCanvas.style.display = 'block';
          const ctx = ui.cryptoChartCanvas.getContext('2d');
          if (!ctx) return; // Ensure context is available

          const coinId = 'BTCz'; // Chart only BTCz for now
          const data = cryptoData[coinId]?.history || [];
          if (data.length === 0) return; // Don't render if no history

          const labels = data.map((_, index) => index + 1); // Simple numerical labels

          const chartConfig = {
               type: 'line',
               data: {
                    labels: labels,
                    datasets: [{
                         label: `${coinId}/USDz`,
                         data: data,
                         borderColor: tg.themeParams.link_color || '#2481cc',
                         backgroundColor: (tg.themeParams.link_color || '#2481cc') + '20', // More transparent fill
                         tension: 0.2, // Slight curve
                         borderWidth: 2,
                         pointRadius: 0, // No points on the line
                         fill: true,
                    }]
               },
               options: {
                    responsive: true,
                    maintainAspectRatio: false, // Allow canvas to resize freely
                    scales: {
                         y: {
                              beginAtZero: false,
                              ticks: { color: tg.themeParams.text_color || '#000', font: { size: 10 } },
                              grid: { color: tg.themeParams.hint_color ? (tg.themeParams.hint_color + '40') : '#99999940' } // Faint grid lines
                         },
                         x: {
                              display: false, // Hide x-axis labels/grid
                              grid: { display: false }
                         }
                    },
                    plugins: {
                         legend: { display: false }, // Hide legend
                         tooltip: { enabled: false } // Disable tooltips for simplicity
                    },
                    animation: { duration: 0 } // Disable initial animation
               }
          };

          if (chartInstance) {
               // Update existing chart data and options
               chartInstance.data.labels = chartConfig.data.labels;
               chartInstance.data.datasets[0].data = chartConfig.data.datasets[0].data;
               chartInstance.data.datasets[0].borderColor = chartConfig.data.datasets[0].borderColor;
               chartInstance.data.datasets[0].backgroundColor = chartConfig.data.datasets[0].backgroundColor;
               chartInstance.options = chartConfig.options; // Update options too (for theme changes)
               chartInstance.update('none'); // Update without animation
          } else {
               // Create new chart instance
               chartInstance = new Chart(ctx, chartConfig);
          }
     }

    /** Renders the list of available mining pools. */
    function renderPools() {
         ui.poolListContainer.innerHTML = ''; // Clear previous list
         const currentHashrate = calculateRigStats().effectiveHashrate; // Get current player hashrate

         for (const id in poolData) {
              const pool = poolData[id];
              const templateNode = ui.poolTemplate.content.cloneNode(true);
              const card = templateNode.querySelector('.pool-card');
              const button = card.querySelector('.pool-action-button');
              const reqElement = card.querySelector('.pool-req');

              let poolBonus = pool.bonus;
               // Apply pool bonus event increase
               if (gameState.activeEvent?.effect.type === 'pool_bonus_increase' && pool.fee > 0) {
                    poolBonus += gameState.activeEvent.effect.amount;
               }

              card.querySelector('.pool-icon').textContent = pool.icon;
              card.querySelector('.pool-name').textContent = pool.name;
              card.querySelector('.pool-description').textContent = pool.description;
              card.querySelector('.pool-bonus').textContent = poolBonus;
              card.querySelector('.pool-fee').textContent = pool.fee;
              reqElement.textContent = pool.minHashrate > 0 ? `‚â• ${pool.minHashrate.toLocaleString()} H/s` : '–ù–µ—Ç';

               const canJoin = currentHashrate >= pool.minHashrate;
               card.classList.toggle('disabled', !canJoin && gameState.currentPoolId !== id); // Dim if cannot join (unless already in)

              if (gameState.currentPoolId === id) {
                   button.textContent = '–í—ã–π—Ç–∏ –∏–∑ –ø—É–ª–∞';
                   button.classList.add('leave');
                   button.disabled = (id === 'pool1'); // Cannot leave 'Solo Miners' pool
                   button.onclick = () => leavePool();
                   reqElement.classList.add('met'); // Show requirement as met if in pool
              } else {
                   button.textContent = '–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è';
                   button.disabled = !canJoin;
                   button.onclick = () => joinPool(id);
                   reqElement.classList.toggle('met', canJoin);
                   reqElement.classList.toggle('not-met', !canJoin && pool.minHashrate > 0); // Style unmet reqs differently?
              }
              ui.poolListContainer.appendChild(card);
         }
    }

    /** Renders the upgrades screen (placeholder). */
    function renderUpgrades() {
        ui.upgradeListContainer.innerHTML = '<p class="placeholder-text">–ó–¥–µ—Å—å –±—É–¥—É—Ç —É–ª—É—á—à–µ–Ω–∏—è –¥–ª—è —Ñ–µ—Ä–º—ã –∏ –Ω–∞–≤—ã–∫–æ–≤ (–≤ —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–µ).</p>';
        // Example Upgrade Structure (if implemented):
        // const upgrades = [ {id: 'eff_1', name: '–≠–Ω–µ—Ä–≥–æ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç—å I', cost: 1000, effectDesc: '-5% –ø–æ—Ç—Ä–µ–±–ª–µ–Ω–∏—è'} ];
        // upgrades.forEach(upg => { /* render upgrade card */ });
    }

    /** Updates the display of the active event banner. */
    function renderActiveEventUI() {
         if (gameState.activeEvent) {
              ui.eventTextElement.textContent = gameState.activeEvent.text;
              // Define icons based on event effect type
               const iconMap = {
                   crypto_price: 'üíπ', shop_discount: 'üõçÔ∏è', shop_price_increase: 'üìà',
                   electricity_cost: '‚ö°', used_market_price: 'üìâ', pool_bonus_increase: 'ü§ù'
               };
               ui.activeEventBanner.querySelector('.icon').textContent = iconMap[gameState.activeEvent.effect.type] || 'üéâ';
              ui.activeEventBanner.style.display = 'block';
              // Optional: Calculate remaining time and display it?
         } else {
              ui.activeEventBanner.style.display = 'none';
         }
    }

    /** Updates all major UI elements based on the current game state. */
    function updateAllUI() {
        applyTheme(); // Ensure theme is current
        const stats = calculateRigStats(); // Calculate stats once for this update cycle

        // --- Update Status Bar ---
        updateStatusBarUI(stats);

        // Update user name (in case it changes, though unlikely in Mini Apps)
        if (tg.initDataUnsafe?.user) {
             ui.userNameElement.textContent = tg.initDataUnsafe.user.first_name || tg.initDataUnsafe.user.username || 'User';
        }

        // --- Update Active Event Banner ---
        renderActiveEventUI();

        // --- Re-render content of the currently active screen ---
        const activeScreen = document.querySelector('.screen.active');
        if (activeScreen) {
            const screenId = activeScreen.id.replace('screen-', '');
            console.log(`Updating UI for active screen: ${screenId}`);
            switch(screenId) {
                case 'main': renderRig(); break;
                case 'shop': renderShop(); break;
                case 'crypto-market': renderCryptoMarket(); break;
                case 'market-used': renderMarketUsed(); break;
                case 'inventory': renderInventory(); break;
                case 'pools-upgrades': renderPools(); renderUpgrades(); break;
                default: console.warn("Active screen not recognized for UI update:", screenId);
            }
        } else {
             console.warn("No active screen found during UI update.");
             switchScreen('main'); // Default to main screen if none active
        }

        // --- Update Mining Target Select ---
         ui.miningCoinSelect.value = gameState.selectedCoinId;

        console.log("UI Update Cycle Completed.");
    }

    /** Updates only the status bar elements. */
    function updateStatusBarUI(stats = null) {
         // Recalculate stats if not provided (e.g., called from gameLoop)
         const currentStats = stats || calculateRigStats();

         ui.balanceElement.textContent = formatUsd(gameState.balance);
         ui.walletBtcz.textContent = formatCrypto(gameState.cryptoWallet.BTCz);
         ui.walletEthz.textContent = formatCrypto(gameState.cryptoWallet.ETHZ);
         ui.walletDogez.textContent = formatCrypto(gameState.cryptoWallet.DOGEz);
         ui.totalHashrateElement.textContent = Math.round(currentStats.effectiveHashrate).toLocaleString();
         ui.totalPowerElement.textContent = Math.round(currentStats.totalPower).toLocaleString();
         ui.powerCostElement.textContent = Math.round(currentStats.electricityCostPerHour).toLocaleString();
         ui.miningTargetElement.textContent = gameState.selectedCoinId;
         const poolName = poolData[gameState.currentPoolId]?.name || '–ù–µ—Ç';
         // Add bonus indication to pool name if applicable
         const poolBonusText = currentStats.poolBonusPercent > 0 ? ` (+${currentStats.poolBonusPercent}%)` : '';
         ui.currentPoolElement.textContent = poolName + poolBonusText;
    }

     /** Updates only the crypto price elements in the status bar or market screen. */
     function updateCryptoPricesUI() {
          // Update prices on market screen if it's active
          if (document.getElementById('screen-crypto-market')?.classList.contains('active')) {
               renderCryptoPricesUI();
          }
          // Potentially update prices shown elsewhere if needed
     }

    /** Updates the estimated income display on the main screen. */
    function updateEstimatedIncomeUI() {
        if (document.getElementById('screen-main')?.classList.contains('active')) {
            const stats = calculateRigStats();
            ui.estimatedIncomeElement.textContent = stats.estimatedNetIncomePerHourCoin.toFixed(4); // More precision for estimate
            ui.estimatedIncomeCoinElement.textContent = gameState.selectedCoinId;
        }
    }


    // --- Action Functions ---

    /** Buys an item from the main shop. */
    function buyItem(itemId) {
        const itemData = componentData[itemId];
        if (!itemData) { console.error("Item data not found:", itemId); return; }

        // Calculate current price considering events
        let currentPrice = itemData.price;
        if (gameState.activeEvent?.effect.type === 'shop_discount' &&
            (!gameState.activeEvent.effect.itemType || gameState.activeEvent.effect.itemType === itemData.type)) {
            currentPrice *= (1 - gameState.activeEvent.effect.discount);
        } else if (gameState.activeEvent?.effect.type === 'shop_price_increase' &&
            (!gameState.activeEvent.effect.itemType || gameState.activeEvent.effect.itemType === itemData.type)) {
            currentPrice *= gameState.activeEvent.effect.multiplier;
        }
        currentPrice = Math.round(currentPrice); // Final price is integer

        if (gameState.balance >= currentPrice) {
             gameState.balance -= currentPrice;
             // Create a new instance of the item
             const newItemInstance = {
                  // Copy necessary base data
                  id: itemData.id,
                  name: itemData.name, // Store name for convenience? Or rely on componentData? Rely for now.
                  type: itemData.type,
                  // Specific stats needed for calculations if base data not always loaded
                  ...(itemData.type === 'gpu' && { hashrate: itemData.hashrate, power: itemData.power }),
                  ...(itemData.type === 'psu' && { capacity: itemData.capacity }),
                  ...(itemData.type === 'motherboard' && { gpuSlots: itemData.gpuSlots, power: itemData.power }),
                  // Instance specific data
                  uid: generateUid(),
                  wear: 0 // New items have zero wear
             };
             gameState.inventory.push(newItemInstance);
             gameState.stats.itemsBought = (gameState.stats.itemsBought || 0) + 1; // Track stats
             console.log(`Bought: ${itemData.name} for ${currentPrice} USDz (UID: ${newItemInstance.uid})`);
             tg.HapticFeedback.notificationOccurred('success');
             updateAllUI(); // Update balance, inventory, shop buttons
             saveGame();
        } else {
            console.log("Not enough USDz to buy item!");
            tg.HapticFeedback.notificationOccurred('error');
            tg.showAlert(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ USDz! –ù—É–∂–Ω–æ ${currentPrice}üí∞.`);
        }
    }

    /** Buys an item from the used market (simulated). */
    function buyFromMarket(listingInstance) {
        if (!listingInstance || !listingInstance.price || !listingInstance.id) {
             console.error("Invalid market listing data provided:", listingInstance);
             tg.showAlert("–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–∫—É–ø–∫–µ —Å –ë/–£ —Ä—ã–Ω–∫–∞.");
             return;
        }

        const baseItemData = componentData[listingInstance.id];
        if (!baseItemData) {
             console.error("Base data not found for market item ID:", listingInstance.id);
             tg.showAlert("–û—à–∏–±–∫–∞ –¥–∞–Ω–Ω—ã—Ö —Ç–æ–≤–∞—Ä–∞.");
             return;
        }

        // Recalculate price considering potential market event at the moment of purchase
        let currentPrice = listingInstance.price;
        if (gameState.activeEvent?.effect.type === 'used_market_price') {
             currentPrice = Math.round(currentPrice * gameState.activeEvent.effect.multiplier);
             currentPrice = Math.max(1, currentPrice); // Min price 1
        }


        if (gameState.balance >= currentPrice) {
            gameState.balance -= currentPrice;

            // Create a new item instance for the player's inventory
            const newItemInstance = {
                id: baseItemData.id,
                name: baseItemData.name,
                type: baseItemData.type,
                // Copy relevant base stats
                ...(baseItemData.type === 'gpu' && { hashrate: baseItemData.hashrate, power: baseItemData.power }),
                ...(baseItemData.type === 'psu' && { capacity: baseItemData.capacity }),
                ...(baseItemData.type === 'motherboard' && { gpuSlots: baseItemData.gpuSlots, power: baseItemData.power }),
                // Instance specific data
                uid: generateUid(), // NEW unique ID for the player's item
                wear: listingInstance.wear || 0, // Carry over the wear
                // Image can be derived from baseItemData later
            };

            gameState.inventory.push(newItemInstance);
             gameState.stats.itemsBought = (gameState.stats.itemsBought || 0) + 1;
            console.log(`Bought used: ${newItemInstance.name} for ${currentPrice} USDz (UID: ${newItemInstance.uid}, Wear: ${newItemInstance.wear.toFixed(2)})`);
            tg.HapticFeedback.notificationOccurred('success');

            // In a real market, we would now notify the backend to remove the listing
            // For simulation, just refresh the market view to get new listings
            renderMarketUsed(); // Re-render market to potentially remove the bought item (or just get new random ones)
            updateStatusBarUI(); // Update balance display
            saveGame();
        } else {
            console.log("Not enough USDz for used market item!");
            tg.HapticFeedback.notificationOccurred('error');
            tg.showAlert(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ USDz! –ù—É–∂–Ω–æ ${currentPrice}üí∞.`);
        }
    }

    /** Installs an item from inventory into the rig. */
    function installItemFromInventory(itemUid, targetType = null, targetIndex = -1) {
         let itemToInstall = null;
         let inventoryIndex = -1;

         // Logic to find the item to install (either by UID or first available of type)
         if (itemUid) { // User clicked "Install" on a specific item
              inventoryIndex = gameState.inventory.findIndex(item => item.uid === itemUid);
              if (inventoryIndex === -1) { console.error("Item to install not found in inventory:", itemUid); return; }
              itemToInstall = gameState.inventory[inventoryIndex];
              targetType = itemToInstall.type; // Determine type from the item itself
         } else if (targetType) { // User clicked on an empty slot
              // Find the first item in inventory matching the target type
              inventoryIndex = gameState.inventory.findIndex(item => item.type === targetType);
              if (inventoryIndex === -1) { tg.showAlert(`–ù–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –ø—Ä–µ–¥–º–µ—Ç–æ–≤ (${targetType}) –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ.`); return; }
              itemToInstall = gameState.inventory[inventoryIndex];
              itemUid = itemToInstall.uid; // Get the UID of the found item
         } else {
              console.error("Invalid call to installItemFromInventory: requires UID or targetType.");
              return;
         }

        let replacedItem = null; // To store the item that was previously in the slot

        // --- Perform Installation ---
        try {
             switch (targetType) {
                  case 'motherboard':
                       replacedItem = gameState.rig.motherboard; // Store old mobo
                       gameState.rig.motherboard = itemToInstall;
                       // Crucially, check GPU slots compatibility AFTER installing new mobo
                       const newMoboData = componentData[itemToInstall.id];
                       const newSlotCount = newMoboData?.gpuSlots || 0;
                       if (gameState.rig.gpuSlots.length > newSlotCount) {
                            // Move excess GPUs back to inventory (handled by renderRig now)
                            console.log("New motherboard has fewer slots, excess GPUs will be moved.");
                       }
                       break;
                  case 'psu':
                       replacedItem = gameState.rig.psu;
                       gameState.rig.psu = itemToInstall;
                       break;
                  case 'gpu':
                       const moboInstance = gameState.rig.motherboard;
                       if (!moboInstance) { tg.showAlert("–°–Ω–∞—á–∞–ª–∞ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ –º–∞—Ç–µ—Ä–∏–Ω—Å–∫—É—é –ø–ª–∞—Ç—É!"); return; }
                       const moboData = componentData[moboInstance.id];
                       const maxSlots = moboData?.gpuSlots || 0;

                       // Ensure targetIndex is valid or find first empty if -1
                       if (targetIndex === -1) targetIndex = gameState.rig.gpuSlots.findIndex(slot => slot === null);
                       if (targetIndex < 0 || targetIndex >= maxSlots) { tg.showAlert("–ù–µ—Ç —Å–≤–æ–±–æ–¥–Ω—ã—Ö —Å–ª–æ—Ç–æ–≤ –¥–ª—è GPU –∏–ª–∏ —Å–ª–æ—Ç –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω."); return; }

                       replacedItem = gameState.rig.gpuSlots[targetIndex]; // Store old GPU (or null)
                       gameState.rig.gpuSlots[targetIndex] = itemToInstall; // Place new GPU
                       break;
                  default:
                       throw new Error(`Unknown item type to install: ${targetType}`);
             }

             // --- Finalize State Update ---
             gameState.inventory.splice(inventoryIndex, 1); // Remove installed item from inventory
             if (replacedItem) {
                  gameState.inventory.push(replacedItem); // Add replaced item back to inventory
                  console.log(`Replaced ${replacedItem.name} (UID: ${replacedItem.uid}), moved to inventory.`);
             }

             console.log(`${itemToInstall.name} (UID: ${itemUid}) installed.`);
             tg.HapticFeedback.impactOccurred('light');
             renderRig(); // Re-render the farm immediately
             renderInventory(); // Update inventory count/items
             updateStatusBarUI(); // Update stats in status bar
             saveGame();

        } catch (error) {
             console.error("Error during installation:", error);
             tg.showAlert("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –ø—Ä–∏ —É—Å—Ç–∞–Ω–æ–≤–∫–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–∞.");
        }
    }

    /** Uninstalls an item from the rig back to inventory. */
    function uninstallItem(itemUid) {
        let itemToUninstall = null;
        let locationUpdated = false;

        // Find item in rig and remove it
        if (gameState.rig.motherboard?.uid === itemUid) {
            itemToUninstall = gameState.rig.motherboard;
            gameState.rig.motherboard = null;
            // Uninstalling mobo also moves all GPUs to inventory
             gameState.rig.gpuSlots.forEach(gpu => { if(gpu) gameState.inventory.push(gpu); });
             gameState.rig.gpuSlots = []; // Clear slots array
            console.log("Motherboard uninstalled, associated GPUs moved to inventory.");
            locationUpdated = true;
        } else if (gameState.rig.psu?.uid === itemUid) {
            itemToUninstall = gameState.rig.psu;
            gameState.rig.psu = null;
            locationUpdated = true;
        } else {
            const gpuIndex = gameState.rig.gpuSlots.findIndex(gpu => gpu?.uid === itemUid);
            if (gpuIndex !== -1) {
                itemToUninstall = gameState.rig.gpuSlots[gpuIndex];
                gameState.rig.gpuSlots[gpuIndex] = null; // Set slot to empty
                locationUpdated = true;
            }
        }

        // Add to inventory if found and removed
        if (itemToUninstall) {
            gameState.inventory.push(itemToUninstall);
            console.log(`${itemToUninstall.name} (UID: ${itemUid}) uninstalled to inventory.`);
            tg.HapticFeedback.impactOccurred('light');
            renderRig();
            renderInventory();
            updateStatusBarUI();
            saveGame();
        } else {
            console.error("Item to uninstall not found in rig:", itemUid);
            // Optional: Show error to user?
        }
    }

    /** Opens the modal window to confirm item repair. */
    function openRepairModal(uid) {
         const found = findItemByUid(uid); // Find item in rig or inventory
         if (!found) { console.error("Item to repair not found:", uid); return; }
         const item = found.item;
         if (!item.wear || item.wear < 0.001) { console.log("Item has no significant wear."); return; } // Don't open if not worn

         const repairCost = calculateRepairCost(item);

         itemToRepairUid = uid; // Store UID for confirmation action
         ui.repairItemNameElement.textContent = componentData[item.id]?.name || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω—ã–π –ø—Ä–µ–¥–º–µ—Ç';
         ui.repairItemWearElement.textContent = (item.wear * 100).toFixed(1);
         ui.repairCostElement.textContent = formatUsd(repairCost);
         ui.confirmRepairButton.disabled = gameState.balance < repairCost; // Disable if not enough money
         ui.repairModal.style.display = 'block'; // Show the modal
    }

    /** Closes the repair modal window. */
    function closeRepairModal() {
         ui.repairModal.style.display = 'none';
         itemToRepairUid = null; // Clear stored UID
    }

    /** Confirms and executes the item repair. */
    function confirmRepair() {
         if (!itemToRepairUid) return; // Exit if no item UID stored

         const found = findItemByUid(itemToRepairUid);
          if (!found) {
              console.error("Item to repair disappeared:", itemToRepairUid);
              tg.showAlert("–û—à–∏–±–∫–∞: –ü—Ä–µ–¥–º–µ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.");
              closeRepairModal();
              return;
          }

         const item = found.item;
         const repairCost = calculateRepairCost(item);

         if (gameState.balance >= repairCost) {
             gameState.balance -= repairCost;
             item.wear = 0; // Reset wear to zero
             gameState.stats.repairsMade = (gameState.stats.repairsMade || 0) + 1; // Track stats
             console.log(`Repaired ${componentData[item.id]?.name || item.id} (UID: ${item.uid}) for ${repairCost} USDz.`);
             tg.HapticFeedback.notificationOccurred('success');
             closeRepairModal();
             // Re-render the screen where the item was (rig or inventory)
             if (found.location === 'rig') renderRig();
             else if (found.location === 'inventory') renderInventory();
             updateStatusBarUI(); // Update balance
             saveGame();
         } else {
              console.log("Not enough USDz for repair!");
              tg.HapticFeedback.notificationOccurred('error');
              tg.showAlert(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ USDz! –ù—É–∂–Ω–æ ${repairCost}üí∞.`);
              // Keep modal open or close it? Close it for now.
              // closeRepairModal();
               ui.confirmRepairButton.disabled = true; // Ensure button stays disabled
         }
    }

    /** Opens the modal to set the price for selling an item on the used market. */
    function openSellModal(uid) {
         // Ensure item is in inventory before allowing listing
         const found = findItemByUid(uid);
         if (!found || found.location !== 'inventory') {
              console.error("Attempted to list item not in inventory:", uid);
              tg.showAlert("–í—ã—Å—Ç–∞–≤–∏—Ç—å –Ω–∞ –ø—Ä–æ–¥–∞–∂—É –º–æ–∂–Ω–æ —Ç–æ–ª—å–∫–æ –ø—Ä–µ–¥–º–µ—Ç—ã –∏–∑ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è.");
              return;
         }
         const item = found.item;
         const baseData = componentData[item.id];
         if (!baseData) { console.error("Missing base data for item to sell:", item.id); return; }

         itemToSellUid = uid; // Store UID for confirmation
         ui.sellItemNameElement.textContent = `${baseData.name} (–ò–∑–Ω–æ—Å: ${(item.wear * 100).toFixed(1)}%)`;
         // Suggest a price based on wear and base price (e.g., 70% of value after wear)
         const suggestedPrice = Math.max(1, Math.floor(baseData.price * (1 - item.wear) * 0.7));
         ui.sellPriceInput.value = suggestedPrice; // Pre-fill suggested price
         ui.sellModal.style.display = 'block'; // Show modal
    }

    /** Closes the sell modal window. */
    function closeSellModal() {
         ui.sellModal.style.display = 'none';
         itemToSellUid = null; // Clear stored UID
    }

    /** Confirms and lists an item from inventory onto the used market. */
    function confirmSell() {
         if (!itemToSellUid) return; // Exit if no UID stored

         const price = parseInt(ui.sellPriceInput.value, 10); // Get price from input
         if (isNaN(price) || price <= 0) {
              tg.showAlert("–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Ü–µ–Ω—É (—Ü–µ–ª–æ–µ —á–∏—Å–ª–æ –±–æ–ª—å—à–µ 0).");
              return;
         }

         // Find the item *again* in inventory to ensure it wasn't moved/installed
         const inventoryIndex = gameState.inventory.findIndex(item => item.uid === itemToSellUid);
         if (inventoryIndex === -1) {
              console.error("Item to list disappeared from inventory:", itemToSellUid);
              tg.showAlert("–û—à–∏–±–∫–∞: –ü—Ä–µ–¥–º–µ—Ç –±–æ–ª—å—à–µ –Ω–µ –≤ –∏–Ω–≤–µ–Ω—Ç–∞—Ä–µ.");
              closeSellModal();
              return;
          }

         // Remove item from inventory and add to market listings
         const itemToList = gameState.inventory.splice(inventoryIndex, 1)[0]; // Remove and get the item
         itemToList.price = price; // Add the selling price to the item object
         gameState.marketListings.push(itemToList);

         console.log(`Item ${componentData[itemToList.id]?.name || itemToList.id} (UID: ${itemToSellUid}) listed for ${price} USDz.`);
         tg.HapticFeedback.notificationOccurred('success');
         closeSellModal();
         renderMarketUsed(); // Update market screen ('Sell' tab)
         renderInventory(); // Update inventory screen
         saveGame();
    }

    /** Removes an item listed by the player from the used market back to inventory. */
    function delistItem(uid) {
         // Find the item in the player's market listings
         const marketIndex = gameState.marketListings.findIndex(item => item.uid === uid);
         if (marketIndex === -1) {
              console.error("Listing to delist not found:", uid);
              tg.showAlert("–û—à–∏–±–∫–∞: –õ–æ—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω.");
              return;
         }

         // Remove item from market listings and add back to inventory
         const itemToDelist = gameState.marketListings.splice(marketIndex, 1)[0]; // Remove and get item
         delete itemToDelist.price; // Remove the selling price property
         gameState.inventory.push(itemToDelist);
          gameState.stats.itemsSold = (gameState.stats.itemsSold || 0) + 1; // Track stats (though not *actually* sold here)

         console.log(`Item ${componentData[itemToDelist.id]?.name || itemToDelist.id} (UID: ${uid}) delisted.`);
         tg.HapticFeedback.notificationOccurred('warning');
         renderMarketUsed(); // Update market screen ('Sell' tab)
         renderInventory(); // Update inventory screen
         saveGame();
    }

    /** Populates the cryptocurrency exchange select dropdowns. */
    function populateExchangeSelects() {
         const currentFrom = ui.exchangeFromCoinSelect.value;
         const currentTo = ui.exchangeToCoinSelect.value;
         ui.exchangeFromCoinSelect.innerHTML = '';
         ui.exchangeToCoinSelect.innerHTML = '';

         for (const id in cryptoData) {
              const option1 = document.createElement('option');
              option1.value = id;
              option1.textContent = `${cryptoData[id].icon} ${id}`;
              ui.exchangeFromCoinSelect.appendChild(option1);

              const option2 = document.createElement('option');
              option2.value = id;
              option2.textContent = `${cryptoData[id].icon} ${id}`;
              ui.exchangeToCoinSelect.appendChild(option2);
         }
         // Restore previous selection if possible, otherwise set defaults
         ui.exchangeFromCoinSelect.value = currentFrom || Object.keys(cryptoData)[0] || '';
         ui.exchangeToCoinSelect.value = currentTo || (Object.keys(cryptoData)[1] || '');

         // Ensure defaults are different if possible
         if (ui.exchangeFromCoinSelect.value === ui.exchangeToCoinSelect.value && ui.exchangeToCoinSelect.options.length > 1) {
               ui.exchangeToCoinSelect.selectedIndex = 1;
         }
         updateExchangeBalance(); // Update the 'Available' amount display
    }

    /** Updates the 'Available' balance display in the exchange form. */
    function updateExchangeBalance() {
         const fromCoinId = ui.exchangeFromCoinSelect.value;
         ui.fromCoinBalanceSpan.textContent = formatCrypto(gameState.cryptoWallet[fromCoinId] || 0);
    }

    /** Updates the estimated receiving amount in the exchange form. */
    function updateExchangeEstimate() {
         const fromCoinId = ui.exchangeFromCoinSelect.value;
         const toCoinId = ui.exchangeToCoinSelect.value;
         const amount = parseFloat(ui.exchangeFromAmountInput.value) || 0;

         ui.exchangeToAmountSpan.textContent = '0'; // Default to 0
         ui.exchangeButton.disabled = true; // Disable button by default

         if (amount <= 0 || fromCoinId === toCoinId || !fromCoinId || !toCoinId) {
              return; // Exit if invalid input
         }

         const fromPrice = gameState.cryptoPrices[fromCoinId];
         const toPrice = gameState.cryptoPrices[toCoinId];

         if (!fromPrice || fromPrice <= 0 || !toPrice || toPrice <= 0) {
              ui.exchangeToAmountSpan.textContent = 'N/A'; // Indicate error if prices unavailable
              console.warn("Exchange price error:", fromCoinId, fromPrice, toCoinId, toPrice);
              return;
         }

         const valueInUsd = amount * fromPrice;
         const fee = valueInUsd * (CONFIG.EXCHANGE_FEE_PERCENT / 100);
         const valueAfterFee = valueInUsd - fee;

         // Ensure value after fee isn't negative (can happen with very small amounts/high fees)
         if (valueAfterFee <= 0) {
             ui.exchangeToAmountSpan.textContent = '0';
             return;
         }

         const estimatedAmount = valueAfterFee / toPrice;
         ui.exchangeToAmountSpan.textContent = formatCrypto(estimatedAmount);

         // Enable button only if valid amount and enough balance
         const availableAmount = gameState.cryptoWallet[fromCoinId] || 0;
         ui.exchangeButton.disabled = (amount > availableAmount);
    }

    /** Executes the cryptocurrency exchange. */
    function executeExchange() {
         const fromCoinId = ui.exchangeFromCoinSelect.value;
         const toCoinId = ui.exchangeToCoinSelect.value;
         const amount = parseFloat(ui.exchangeFromAmountInput.value);

         // Re-validate all conditions before executing
         if (isNaN(amount) || amount <= 0) { tg.showAlert("–í–≤–µ–¥–∏—Ç–µ –∫–æ—Ä—Ä–µ–∫—Ç–Ω—É—é —Å—É–º–º—É –¥–ª—è –æ–±–º–µ–Ω–∞."); return; }
         if (fromCoinId === toCoinId) { tg.showAlert("–í—ã–±–µ—Ä–∏—Ç–µ —Ä–∞–∑–Ω—ã–µ –≤–∞–ª—é—Ç—ã –¥–ª—è –æ–±–º–µ–Ω–∞."); return; }

         const availableAmount = gameState.cryptoWallet[fromCoinId] || 0;
         if (amount > availableAmount) { tg.showAlert(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ ${fromCoinId}! –î–æ—Å—Ç—É–ø–Ω–æ: ${formatCrypto(availableAmount)}`); return; }

         const fromPrice = gameState.cryptoPrices[fromCoinId];
         const toPrice = gameState.cryptoPrices[toCoinId];
         if (!fromPrice || fromPrice <= 0 || !toPrice || toPrice <= 0) { tg.showAlert("–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫—É—Ä—Å–∞ –æ–±–º–µ–Ω–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."); return; }

         // Recalculate exact amounts based on current prices
         const valueInUsd = amount * fromPrice;
         const fee = valueInUsd * (CONFIG.EXCHANGE_FEE_PERCENT / 100);
         const valueAfterFee = valueInUsd - fee;
         if (valueAfterFee <= 0) { tg.showAlert("–°—É–º–º–∞ —Å–ª–∏—à–∫–æ–º –º–∞–ª–∞ –¥–ª—è –æ–±–º–µ–Ω–∞ –ø–æ—Å–ª–µ –∫–æ–º–∏—Å—Å–∏–∏."); return;}
         const receivedAmount = valueAfterFee / toPrice;

         // --- Update Game State ---
         gameState.cryptoWallet[fromCoinId] -= amount;
         gameState.cryptoWallet[toCoinId] = (gameState.cryptoWallet[toCoinId] || 0) + receivedAmount;

         console.log(`Exchanged ${amount.toFixed(6)} ${fromCoinId} to ${receivedAmount.toFixed(6)} ${toCoinId}. Fee (USDz value): ${fee.toFixed(4)}`);
         tg.HapticFeedback.notificationOccurred('success');

         // --- Update UI ---
         ui.exchangeFromAmountInput.value = ''; // Clear input field
         updateExchangeBalance(); // Update available amount display
         updateExchangeEstimate(); // Reset estimate and disable button
         updateStatusBarUI(); // Update wallet display in status bar
         saveGame();
    }

    /** Joins a specified mining pool. */
    function joinPool(poolId) {
         const pool = poolData[poolId];
         if (!pool) { console.error("Pool not found:", poolId); return; }
         if (gameState.currentPoolId === poolId) { console.log("Already in this pool."); return; } // Already joined

         const currentStats = calculateRigStats(); // Get current stats
         if (currentStats.effectiveHashrate < pool.minHashrate) {
              tg.showAlert(`–ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Ö–µ—à—Ä–µ–π—Ç–∞ –¥–ª—è –ø—Ä–∏—Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –∫ "${pool.name}". –¢—Ä–µ–±—É–µ—Ç—Å—è ${pool.minHashrate.toLocaleString()} H/s.`);
              return;
         }

         gameState.currentPoolId = poolId;
         console.log(`Joined pool: ${pool.name}`);
         tg.HapticFeedback.impactOccurred('light');
         renderPools(); // Re-render pool list to update buttons/status
         updateStatusBarUI(); // Update pool name in status bar
         saveGame();
    }

    /** Leaves the current mining pool and returns to Solo. */
    function leavePool() {
        if (gameState.currentPoolId === 'pool1') { console.log("Already in Solo pool."); return; } // Cannot leave solo

        const oldPoolName = poolData[gameState.currentPoolId]?.name || 'Unknown Pool';
        gameState.currentPoolId = 'pool1'; // Return to Solo
        console.log(`Left pool: ${oldPoolName}. Returned to Solo Mining.`);
        tg.HapticFeedback.impactOccurred('light');
        renderPools();
        updateStatusBarUI();
        saveGame();
    }

    // --- Navigation ---

    /** Switches the active screen displayed to the user. */
    function switchScreen(screenId) {
        // Hide all screens first
        ui.screens.forEach(screen => screen.classList.remove('active'));
        // Deactivate all nav buttons
        ui.navButtons.forEach(button => button.classList.remove('active'));

        const targetScreen = document.getElementById(`screen-${screenId}`);
        const targetButton = document.querySelector(`.nav-button[data-screen="${screenId}"]`);

        if (targetScreen) {
            targetScreen.classList.add('active');
             console.log(`Switched to screen: ${screenId}`);
            // Trigger specific render/update logic for the newly activated screen
            // This ensures data is fresh when switching back to a screen
             switch(screenId) {
                 case 'main': renderRig(); break;
                 case 'shop': renderShop(); break;
                 case 'crypto-market': renderCryptoMarket(); break; // Includes prices, chart, exchange form
                 case 'market-used': renderMarketUsed(); break;
                 case 'inventory': renderInventory(); break;
                 case 'pools-upgrades': renderPools(); renderUpgrades(); break;
                 default: console.warn("Unhandled screen activation:", screenId);
             }
        } else {
             console.error(`Screen element not found: #screen-${screenId}`);
             // Optionally switch to a default screen like 'main'
             switchScreen('main');
             return; // Exit early to avoid errors with targetButton
        }

        // Activate the corresponding nav button
        if (targetButton) {
            targetButton.classList.add('active');
        } else {
            console.warn(`Nav button not found for screen: ${screenId}`);
        }
         // Optional: Scroll to top of the new screen
         const contentArea = document.querySelector('.content');
         if (contentArea) contentArea.scrollTop = 0;

         // Optional: Update BackButton behavior based on screen
         // if (screenId === 'main') {
         //     tg.BackButton.hide();
         // } else {
         //     tg.BackButton.show();
         // }
    }


    // --- Initialization ---

    /** Sets up all event listeners for the application. */
    function setupEventListeners() {
        // Navigation Buttons
        ui.navButtons.forEach(button => {
            button.addEventListener('click', () => {
                const screenId = button.dataset.screen;
                if (screenId) switchScreen(screenId);
            });
        });

        // Used Market Tab Buttons
        ui.marketTabButtons.forEach(button => {
            button.addEventListener('click', (e) => {
                 const marketScreen = e.target.closest('#screen-market-used'); // Ensure we're on the correct screen
                 if (!marketScreen) return;
                 const tabId = button.dataset.marketTab; // 'buy' or 'sell'

                 // Deactivate other tabs and content panes within this screen
                 marketScreen.querySelectorAll('.market-tabs .tab-button').forEach(btn => btn.classList.remove('active'));
                 marketScreen.querySelectorAll('.market-tab-content').forEach(content => content.classList.remove('active'));

                 // Activate clicked tab and corresponding content pane
                 button.classList.add('active');
                 const contentElement = marketScreen.querySelector(`#market-items-${tabId}`);
                 if (contentElement) contentElement.classList.add('active');

                 // Re-render the market content when switching tabs
                 renderMarketUsed();
            });
        });

        // Mining Target Selection Change
        ui.miningCoinSelect.addEventListener('change', (e) => {
             const newCoinId = e.target.value;
             if (cryptoData[newCoinId]) {
                  gameState.selectedCoinId = newCoinId;
                  console.log(`Selected coin for mining: ${gameState.selectedCoinId}`);
                  updateEstimatedIncomeUI(); // Update income estimate immediately
                  updateStatusBarUI(); // Update target display in status bar
                  saveGame(); // Save the selection
             }
        });

        // Crypto Exchange Form Listeners
        ui.exchangeFromCoinSelect.addEventListener('change', () => {
             // Ensure 'from' and 'to' are different
             if (ui.exchangeFromCoinSelect.value === ui.exchangeToCoinSelect.value) {
                  // Find the next available option for 'to'
                   let nextIndex = (ui.exchangeFromCoinSelect.selectedIndex + 1) % ui.exchangeFromCoinSelect.options.length;
                   ui.exchangeToCoinSelect.selectedIndex = nextIndex;
             }
             updateExchangeBalance();
             updateExchangeEstimate();
        });
        ui.exchangeToCoinSelect.addEventListener('change', updateExchangeEstimate);
        ui.exchangeFromAmountInput.addEventListener('input', updateExchangeEstimate);
        ui.exchangeButton.addEventListener('click', executeExchange);

        // Modal Close Buttons
        ui.sellModalCloseButton.addEventListener('click', closeSellModal);
        ui.repairModalCloseButton.addEventListener('click', closeRepairModal);

        // Modal Confirm Buttons
        ui.confirmSellButton.addEventListener('click', confirmSell);
        ui.confirmRepairButton.addEventListener('click', confirmRepair);

        // Close modals on background click
        window.addEventListener('click', (event) => {
            if (event.target === ui.sellModal) closeSellModal();
            if (event.target === ui.repairModal) closeRepairModal();
        });

        // Telegram specific events
        tg.onEvent('themeChanged', applyTheme); // Update theme when changed in Telegram
        // tg.BackButton.onClick(() => {
        //      // Handle back button logic (e.g., switch to main screen or previous screen)
        //      const activeScreenId = document.querySelector('.screen.active')?.id.replace('screen-', '');
        //      if (activeScreenId !== 'main') {
        //           switchScreen('main');
        //      } else {
        //           // Optionally close the Mini App if already on main screen
        //           // tg.close();
        //      }
        // });
    }

    /** Main initialization function for the application. */
    function initializeApp() {
        console.log("Initializing Crypto Baron Mini v2...");
        loadGame(); // Load saved state or initialize new game
        applyTheme(); // Apply Telegram theme colors

        // Setup Game Intervals
        // Clear existing timers first (in case of hot-reloading or re-initialization)
        Object.values(timers).forEach(timerId => { if (timerId) clearInterval(timerId); });

        timers.gameLoop = setInterval(gameLoop, CONFIG.TICK_INTERVAL);
        timers.saveGame = setInterval(saveGame, CONFIG.SAVE_INTERVAL);
        timers.cryptoUpdate = setInterval(simulateCryptoMarket, CONFIG.CRYPTO_UPDATE_INTERVAL);
        timers.eventCheck = setInterval(() => {
            checkActiveEventExpiry();
            triggerRandomEvent();
        }, CONFIG.EVENT_CHECK_INTERVAL);

        // Populate any static UI elements needed at start
        ui.miningCoinSelect.value = gameState.selectedCoinId; // Set initial select value

        // Initial full UI Render based on loaded/initialized state
        updateAllUI();

        // Activate the default starting screen
        switchScreen('main');

        // Setup all event listeners
        setupEventListeners();

        // Show the back button? Only if not on main screen initially?
        // tg.BackButton.hide(); // Hide initially

        console.log("Initialization Complete. Game Running.");
        // Maybe send an analytics event for app start?
    }

    // --- Start the App ---
    initializeApp();

}); // End DOMContentLoaded
